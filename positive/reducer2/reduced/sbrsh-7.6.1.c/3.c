/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 37 "/usr/include/stdint.h"
typedef short int16_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/types.h"
typedef unsigned int bool_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
enum __anonenum_mtype_t_25 {
    MTYPE_NFS = 1,
    MTYPE_BIND = 2,
    MTYPE_SSH = 3
} ;
#line 15 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef enum __anonenum_mtype_t_25 mtype_t;
#line 26
struct mount_info_s;
#line 26
struct mount_info_s;
#line 30 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_info_s {
   mtype_t type ;
   char *point ;
   char *device ;
   char *opts ;
   dev_t device_dev ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef struct mount_info_s mount_info_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
struct __anonstruct_uint16v_t_26 {
   uint32_t len ;
   uint16_t *vec ;
};
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
typedef struct __anonstruct_uint16v_t_26 uint16v_t;
#line 62
enum __anonenum_ptype_t_27 {
    PTYPE_VERSION = 11,
    PTYPE_MESSAGE = 16,
    PTYPE_ERROR = 17,
    PTYPE_USER = 34,
    PTYPE_AUTH = 35,
    PTYPE_RC = 36,
    PTYPE_COMMAND = 48,
    PTYPE_MOUNT = 49,
    PTYPE_UMOUNT = 50,
    PTYPE_TARGET = 65,
    PTYPE_MOUNTS = 66,
    PTYPE_ARGS = 80,
    PTYPE_CWD = 81,
    PTYPE_ENVIRON = 82,
    PTYPE_IDS = 83,
    PTYPE_UMASK = 84,
    PTYPE_WINSIZE = 85,
    PTYPE_IN_REQ = 96,
    PTYPE_IN_DATA = 97,
    PTYPE_OUT_REQ = 98,
    PTYPE_OUT_DATA = 99,
    PTYPE_ERR_REQ = 100,
    PTYPE_ERR_DATA = 101
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
typedef enum __anonenum_ptype_t_27 ptype_t;
#line 17 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
struct __anonstruct_buffer_t_28 {
   size_t start ;
   size_t end ;
   bool_t eof ;
   size_t mem_size ;
   uint8_t *mem ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
typedef struct __anonstruct_buffer_t_28 buffer_t;
#line 14 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
struct __anonstruct_config_t_29 {
   char *target ;
   char *host ;
   char *port ;
   char **opts ;
};
#line 14 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
typedef struct __anonstruct_config_t_29 config_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_42 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_43 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_44 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_45 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_46 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_47 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_48 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_41 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_42 _kill ;
   struct __anonstruct__timer_43 _timer ;
   struct __anonstruct__rt_44 _rt ;
   struct __anonstruct__sigchld_45 _sigchld ;
   struct __anonstruct__sigfault_46 _sigfault ;
   struct __anonstruct__sigpoll_47 _sigpoll ;
   struct __anonstruct__sigsys_48 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_40 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_41 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_40 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_60 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_60 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
struct __anonstruct_sel_57 {
   char nfs_path[4096] ;
   char *path ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
typedef void free_func_t(void * );
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_s;
#line 27
struct mount_s;
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
struct mount_s {
   struct mount_s *prev ;
   struct mount_s *next ;
   unsigned int usage ;
   time_t expiration ;
   struct mount_info_s info ;
   dev_t point_dev ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
typedef struct mount_s mount_t;
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_input_desc_t_35 {
   int fd ;
   bool_t wait ;
   buffer_t *buf ;
   ptype_t req_type ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_input_desc_t_35 input_desc_t;
#line 89 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_output_desc_t_36 {
   int fd ;
   size_t req ;
   ptype_t data_type ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_output_desc_t_36 output_desc_t;
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_param_38 {
   char *target ;
   mount_info_t **mounts ;
   char **args ;
   char *cwd ;
   char **environ ;
   uint16v_t *ids ;
   uint16_t umask ;
   struct winsize *term ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
struct __anonstruct_handler_t_37 {
   int sd ;
   int client_version ;
   char host[1025] ;
   char const   *user ;
   struct __anonstruct_param_38 param ;
   char *root ;
   mount_t **mounts ;
   input_desc_t in ;
   output_desc_t out ;
   output_desc_t err ;
   char tmp_buf[4096] ;
   char *fakerootkey ;
   bool_t error ;
};
#line 101 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
typedef struct __anonstruct_handler_t_37 handler_t;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
struct __anonstruct_debug_info_88 {
   pid_t pid ;
   char const   *name ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 24 "./fakeroot/message.h"
typedef uint32_t func_id_t;
#line 26 "./fakeroot/message.h"
typedef uint64_t fake_ino_t;
#line 27 "./fakeroot/message.h"
typedef uint64_t fake_dev_t;
#line 28 "./fakeroot/message.h"
typedef uint32_t fake_uid_t;
#line 29 "./fakeroot/message.h"
typedef uint32_t fake_gid_t;
#line 30 "./fakeroot/message.h"
typedef uint32_t fake_mode_t;
#line 31 "./fakeroot/message.h"
typedef uint32_t fake_nlink_t;
#line 33 "./fakeroot/message.h"
struct fakestat {
   fake_uid_t uid ;
   fake_gid_t gid ;
   fake_ino_t ino ;
   fake_dev_t dev ;
   fake_dev_t rdev ;
   fake_mode_t mode ;
   fake_nlink_t nlink ;
} __attribute__((__packed__)) ;
#line 43 "./fakeroot/message.h"
struct fake_msg {
   func_id_t id ;
   struct fakestat st ;
   uint32_t remote ;
} __attribute__((__packed__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
enum __anonenum_direction_t_67 {
    DAEMON_TO_CLIENT = 0,
    CLIENT_TO_DAEMON = 1
} ;
#line 28 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
typedef enum __anonenum_direction_t_67 direction_t;
#line 33
struct node_s;
#line 33
struct node_s;
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
struct node_s {
   struct node_s *next ;
   int client ;
   int daemon ;
   fake_dev_t stored_dev ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
typedef struct node_s node_t;
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.h"
void error(char const   *msg  , ...) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
int set_nonblocking(int fd , bool_t nonblock ) ;
#line 36
char *get_progname(char *name ) ;
#line 39
size_t calc_vec_len(void **vec ) ;
#line 54
void oom_error(void) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
mount_info_t *mntinfo_parse(char const   *input ) ;
#line 69
int mntinfo_stat_device(mount_info_t *mi ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
uint16v_t *uint16v_alloc(uint32_t len ) ;
#line 27
void uint16v_free(uint16v_t *ints ) ;
#line 33
int read_buf(int fd , void *buf , size_t len ) ;
#line 36
int read_uint16(int fd , uint16_t *iptr ) ;
#line 39
int read_uint32(int fd , uint32_t *iptr ) ;
#line 44
int write_uint16v(int fd , uint16v_t *ints ) ;
#line 50
int write_strv(int fd , char **strv ) ;
#line 56
int write_mountv(int fd , mount_info_t **mounts ) ;
#line 59
int write_winsize(int fd , struct winsize  const  *ws ) ;
#line 94
int write_enum(int fd , int type ) ;
#line 95
int read_enum(int fd ) ;
#line 97
int write_buf_packet(int fd , ptype_t type , size_t size , void *buf ) ;
#line 98
int write_str_packet(int fd , ptype_t type , char const   *str ) ;
#line 99
int write_uint16_packet(int fd , ptype_t type , uint16_t val ) ;
#line 101
int send_version(int fd ) ;
#line 102
int get_version(int fd ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
buffer_t *buf_alloc(void) ;
#line 29
bool_t buf_is_empty(buffer_t *buf ) ;
#line 30
ssize_t buf_read_in(buffer_t *buf , int fd , size_t len ) ;
#line 31
ssize_t buf_write_out(buffer_t *buf , int *fd ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
config_t *config_alloc(void) ;
#line 22
void config_free(config_t *cfg ) ;
#line 23
bool_t config_read(config_t *cfg , char const   *filename , char const   *target___0 ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
extern char **environ ;
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *progname  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *configpath  =    (char *)((void *)0);
#line 48 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *target  =    (char *)((void *)0);
#line 49 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *remote_user  =    (char *)((void *)0);
#line 50 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *cwd  =    (char *)((void *)0);
#line 51 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char **args  =    (char **)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int action  =    48;
#line 55 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int sd  =    -1;
#line 58 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static buffer_t *buf_out  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static buffer_t *buf_err  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char *tmp_buf  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t rawmode  =    (bool_t )0;
#line 66 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static struct termios oldtio  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static size_t inreq  =    (size_t )0;
#line 72 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t outwait  =    (bool_t )0;
#line 73 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t errwait  =    (bool_t )0;
#line 76 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int daemon_version  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
void error(char const   *msg  , ...) 
{ 
  char *desc ;
  va_list arg ;
  int *tmp ;
  int *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 101
  desc = (char *)((void *)0);
#line 104
  tmp___0 = __errno_location();
  }
#line 104
  if (*tmp___0 > 0) {
    {
#line 105
    tmp = __errno_location();
#line 105
    desc = strerror(*tmp);
    }
  }
  {
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          progname);
#line 113
  __builtin_va_start(arg, msg);
#line 114
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           arg);
#line 115
  __builtin_va_end(arg);
  }
#line 117
  if (desc) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
            desc);
    }
  }
  {
#line 120
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 121
  fflush(stderr);
  }
#line 122
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int write_buffer(buffer_t *buf , int fd , bool_t *wait ) 
{ 
  char const   *tmp ;
  ssize_t tmp___0 ;
  bool_t tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 134
  tmp___0 = buf_write_out(buf, & fd);
  }
#line 134
  if (tmp___0 < 0L) {
#line 135
    if (fd == 1) {
#line 135
      tmp = "Can\'t write buffer to stdout";
    } else {
#line 135
      tmp = "Can\'t write buffer to stderr";
    }
    {
#line 135
    error(tmp);
    }
#line 138
    return (-1);
  }
  {
#line 141
  tmp___1 = buf_is_empty(buf);
  }
#line 141
  if (tmp___1) {
#line 142
    *wait = (bool_t )0;
  }
#line 144
  return (0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int send_data(void) 
{ 
  bool_t ok ;
  ssize_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 153
  ok = (bool_t )0;
#line 154
  len = (ssize_t )4096;
#line 159
  tmp___0 = isatty(0);
  }
#line 159
  if (tmp___0) {
    {
#line 160
    tmp = ioctl(0, 21531UL, & len);
    }
#line 160
    if (tmp < 0) {
      {
#line 161
      error("Can\'t check tty for available data");
      }
#line 162
      return (-1);
    }
#line 165
    if (len < 0L) {
      {
#line 166
      error("ioctl(tty) gave invalid read length");
      }
#line 167
      return (-1);
    }
#line 170
    if (len == 0L) {
#line 171
      return (0);
    }
#line 173
    if (len > 4096L) {
#line 174
      len = (ssize_t )4096;
    }
  }
  {
#line 177
  len = read(0, (void *)tmp_buf, (size_t )len);
  }
#line 178
  if (len < 0L) {
    {
#line 179
    error("Can\'t read from stdin");
    }
#line 180
    return (-1);
  }
#line 183
  if (len == 0L) {
#line 185
    ok = (bool_t )1;
#line 186
    inreq = (size_t )0;
  }
  {
#line 189
  tmp___1 = write_buf_packet(sd, (ptype_t )97, (size_t )len, (void *)tmp_buf);
  }
#line 189
  if (tmp___1 < 0) {
    {
#line 190
    error("Can\'t write IN DATA packet to socket");
    }
#line 191
    return (-1);
  }
#line 195
  inreq -= (size_t )len;
#line 197
  return ((int )ok);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_stream(buffer_t *buf ) 
{ 
  uint32_t len ;
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 208
  tmp = read_uint32(sd, & len);
  }
#line 208
  if (tmp < 0) {
    {
#line 209
    error("Unable to read data packet length");
    }
#line 210
    return (-1);
  }
#line 213
  if (len == 0U) {
    {
#line 214
    tmp___0 = __errno_location();
#line 214
    *tmp___0 = 0;
#line 215
    error("Received empty data packet (EOF)");
    }
#line 216
    return (-1);
  }
  {
#line 219
  tmp___1 = buf_read_in(buf, sd, (size_t )len);
  }
#line 219
  if (tmp___1 < 0L) {
    {
#line 220
    error("Can\'t append data packet to buffer");
    }
#line 221
    return (-1);
  }
#line 224
  return (0);
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_message(ptype_t type ) 
{ 
  uint32_t len ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 235
  tmp = read_uint32(sd, & len);
  }
#line 235
  if (tmp < 0) {
    {
#line 236
    error("Unable to read message packet length");
    }
#line 237
    return (-1);
  }
  {
#line 240
  tmp___0 = read_buf(sd, (void *)tmp_buf, (size_t )len);
  }
#line 240
  if (tmp___0 < 0) {
    {
#line 241
    error("Can\'t read message packet");
    }
#line 242
    return (-1);
  }
#line 245
  if (len == 4096U) {
#line 246
    len = (uint32_t )4095;
  }
#line 248
  *(tmp_buf + len) = (char )'\000';
#line 256
  if ((unsigned int )type == 17U) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s server: %s\n",
            progname, tmp_buf);
    }
  } else {
    {
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            progname, tmp_buf);
    }
  }
#line 262
  return (0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int receive_packet(uint16_t *rc ) 
{ 
  ptype_t type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 272
  tmp = read_enum(sd);
#line 272
  type = (ptype_t )tmp;
  }
#line 274
  if ((unsigned int )type == 4294967295U) {
#line 274
    goto case_4294967295;
  }
#line 278
  if ((unsigned int )type == 96U) {
#line 278
    goto case_96;
  }
#line 282
  if ((unsigned int )type == 99U) {
#line 282
    goto case_99;
  }
#line 285
  if ((unsigned int )type == 101U) {
#line 285
    goto case_101;
  }
#line 288
  if ((unsigned int )type == 36U) {
#line 288
    goto case_36;
  }
#line 296
  if ((unsigned int )type == 16U) {
#line 296
    goto case_16;
  }
#line 299
  if ((unsigned int )type == 17U) {
#line 299
    goto case_17;
  }
#line 302
  goto switch_default;
  case_4294967295: 
  {
#line 275
  error("Can\'t read packet type from socket");
  }
#line 276
  return (-1);
  case_96: 
#line 279
  inreq = (size_t )4096;
#line 280
  return (0);
  case_99: 
  {
#line 283
  tmp___0 = receive_stream(buf_out);
  }
#line 283
  return (tmp___0);
  case_101: 
  {
#line 286
  tmp___1 = receive_stream(buf_err);
  }
#line 286
  return (tmp___1);
  case_36: 
  {
#line 290
  tmp___2 = read_uint16(sd, rc);
  }
#line 290
  if (tmp___2 < 0) {
    {
#line 291
    error("Can\'t read RC packet from socket");
    }
#line 292
    return (-1);
  }
#line 294
  return (1);
  case_16: 
  {
#line 297
  tmp___3 = receive_message((ptype_t )16);
  }
#line 297
  return (tmp___3);
  case_17: 
  {
#line 300
  tmp___4 = receive_message((ptype_t )17);
  }
#line 300
  return (tmp___4);
  switch_default: 
  {
#line 303
  tmp___5 = __errno_location();
#line 303
  *tmp___5 = 0;
#line 304
  error("Received packet has unexpected type (0x%02x)", (unsigned int )type);
  }
#line 305
  return (-1);

#line 309
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int send_request(ptype_t ptype , bool_t *wait ) 
{ 
  int tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 317
  tmp = write_enum(sd, (int )ptype);
  }
#line 317
  if (tmp < 0) {
    {
#line 318
    error("Can\'t write packet to socket");
    }
#line 319
    return (-1);
  }
#line 322
  *wait = (bool_t )1;
#line 324
  return (0);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int manage(bool_t is_tty ) 
{ 
  fd_set readfds ;
  fd_set writefds ;
  bool_t inopen ;
  int ok ;
  ssize_t tmp ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  bool_t tmp___0 ;
  bool_t tmp___1 ;
  int tmp___2 ;
  uint16_t rc ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  bool_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  bool_t tmp___10 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 338
  if (is_tty) {
#line 339
    inopen = (bool_t )1;
  } else {
    {
#line 338
    tmp = read(0, (void *)0, (size_t )0);
    }
#line 338
    if (tmp != -1L) {
#line 339
      inopen = (bool_t )1;
    } else {
#line 341
      inopen = (bool_t )0;
    }
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 345
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.__fds_bits[0]): "memory");
#line 345
      goto while_break___0;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
    {
#line 346
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 346
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& writefds.__fds_bits[0]): "memory");
#line 346
      goto while_break___1;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___1: 
#line 348
    readfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 350
    if (inopen) {
#line 350
      if (inreq) {
#line 351
        readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
      }
    }
    {
#line 353
    tmp___0 = buf_is_empty(buf_out);
    }
#line 353
    if (tmp___0) {
#line 353
      if (! outwait) {
#line 354
        writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 1 % (8 * (int )sizeof(__fd_mask ));
      }
    } else {
#line 354
      writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 1 % (8 * (int )sizeof(__fd_mask ));
    }
#line 356
    if (! is_tty) {
      {
#line 356
      tmp___1 = buf_is_empty(buf_err);
      }
#line 356
      if (tmp___1) {
#line 356
        if (! errwait) {
#line 357
          writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 2 % (8 * (int )sizeof(__fd_mask ));
        }
      } else {
#line 357
        writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 2 % (8 * (int )sizeof(__fd_mask ));
      }
    }
    {
#line 359
    tmp___2 = select(sd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
                     (fd_set */* __restrict  */)((fd_set *)((void *)0)), (struct timeval */* __restrict  */)((struct timeval *)((void *)0)));
    }
#line 359
    if (tmp___2 <= 0) {
      {
#line 360
      error("Can\'t select");
      }
#line 361
      return (-1);
    }
#line 365
    if ((readfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 368
      ok = receive_packet(& rc);
      }
#line 369
      if (ok < 0) {
#line 370
        return (-1);
      }
#line 372
      if (ok > 0) {
#line 373
        return ((int )rc);
      }
    }
#line 377
    if (inopen) {
#line 377
      if (inreq) {
#line 377
        if ((readfds.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 378
          ok = send_data();
          }
#line 379
          if (ok < 0) {
#line 380
            return (-1);
          }
#line 381
          if (ok > 0) {
#line 382
            inopen = (bool_t )0;
          }
        }
      }
    }
#line 386
    if ((writefds.__fds_bits[1 / (8 * (int )sizeof(__fd_mask ))] & (1L << 1 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 387
      tmp___6 = buf_is_empty(buf_out);
      }
#line 387
      if (tmp___6) {
#line 388
        if (outwait) {
#line 388
          tmp___4 = 1;
        } else {
          {
#line 388
          tmp___3 = send_request((ptype_t )98, & outwait);
          }
#line 388
          if (tmp___3 >= 0) {
#line 388
            tmp___4 = 1;
          } else {
#line 388
            tmp___4 = 0;
          }
        }
#line 388
        ok = tmp___4;
      } else {
        {
#line 390
        tmp___5 = write_buffer(buf_out, 1, & outwait);
#line 390
        ok = tmp___5 >= 0;
        }
      }
#line 392
      if (! ok) {
#line 393
        return (-1);
      }
    }
#line 397
    if ((writefds.__fds_bits[2 / (8 * (int )sizeof(__fd_mask ))] & (1L << 2 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 398
      tmp___10 = buf_is_empty(buf_err);
      }
#line 398
      if (tmp___10) {
#line 399
        if (errwait) {
#line 399
          tmp___8 = 1;
        } else {
          {
#line 399
          tmp___7 = send_request((ptype_t )100, & errwait);
          }
#line 399
          if (tmp___7 >= 0) {
#line 399
            tmp___8 = 1;
          } else {
#line 399
            tmp___8 = 0;
          }
        }
#line 399
        ok = tmp___8;
      } else {
        {
#line 401
        tmp___9 = write_buffer(buf_err, 2, & errwait);
#line 401
        ok = tmp___9 >= 0;
        }
      }
#line 403
      if (! ok) {
#line 404
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 409
  return (-1);
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int set_raw_mode(void) 
{ 
  struct termios tio ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 419
  tmp = tcgetattr(0, & tio);
  }
#line 419
  if (tmp < 0) {
    {
#line 420
    error("Can\'t get termios");
    }
#line 421
    return (-1);
  }
  {
#line 424
  oldtio = tio;
#line 426
  tio.c_iflag |= 4U;
#line 427
  tio.c_iflag &= 4294963743U;
#line 428
  tio.c_lflag &= 4294963140U;
#line 429
  tio.c_lflag &= 4294934462U;
#line 430
  tio.c_cc[6] = (cc_t )1;
#line 431
  tio.c_cc[5] = (cc_t )0;
#line 435
  tmp___0 = tcsetattr(0, 1, (struct termios  const  *)(& tio));
  }
#line 435
  if (tmp___0 < 0) {
    {
#line 436
    error("Can\'t change termios");
    }
#line 437
    return (-1);
  }
#line 440
  rawmode = (bool_t )1;
#line 442
  return (0);
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void set_old_mode(void) 
{ 
  int tmp ;
  char *__cil_tmp2 ;

  {
#line 450
  if (! rawmode) {
#line 452
    return;
  }
  {
#line 457
  tmp = tcsetattr(0, 1, (struct termios  const  *)(& oldtio));
  }
#line 457
  if (tmp < 0) {
    {
#line 458
    error("Can\'t restore original termios");
    }
  }
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void usage(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 463
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-t|--target <target>] [-c|--config <path>] [-d|--directory <dir>] [-r|--remote <uid>,<gid>,<username>] [<command>] [<args>]\n       %s [-t|--target <target>] [-c|--config <path>] --mount\n       %s [-t|--target <target>] [-c|--config <path>] --umount\n       %s -v|--version\n       %s -h|--help\n",
          progname, progname, progname, progname, progname);
  }
#line 478
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static bool_t should_skip_parameter(char *arg , struct option *longopts ) 
{ 
  bool_t is_long ;
  struct option *opt ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 485
  tmp = strlen((char const   *)arg);
#line 485
  is_long = (bool_t )(tmp > 2UL);
  }
#line 488
  if (is_long) {
    {
#line 488
    tmp___0 = strchr((char const   *)arg, '=');
    }
#line 488
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 489
      return ((bool_t )0);
    }
  }
#line 491
  opt = longopts;
  {
#line 491
  while (1) {
    while_continue: /* CIL Label */ ;

#line 491
    if (! opt->name) {
#line 491
      goto while_break;
    }
#line 492
    if (is_long) {
      {
#line 493
      tmp___1 = strcmp((char const   *)(arg + 2), opt->name);
      }
#line 493
      if (tmp___1 != 0) {
#line 494
        goto __Cont;
      }
    } else
#line 496
    if ((int )*(arg + 1) != opt->val) {
#line 497
      goto __Cont;
    }
#line 500
    return ((bool_t )(opt->has_arg == 1));
    __Cont: 
#line 491
    opt ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 503
  return ((bool_t )0);
}
}
#line 506 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static char **modify_args(int old_argc , char **old_argv , int *new_argc , struct option *longopts ) 
{ 
  char **new_argv ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  char **tmp___1 ;
  char *arg ;
  char **tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char **tmp___7 ;
  bool_t tmp___8 ;
  int tmp___9 ;
  char **tmp___10 ;
  char *__cil_tmp20 ;

  {
  {
#line 509
  i = 0;
#line 511
  tmp = calloc((size_t )(old_argc + 2), sizeof(char *));
#line 511
  new_argv = (char **)tmp;
  }
#line 512
  if (! new_argv) {
    {
#line 513
    oom_error();
#line 514
    exit(1);
    }
  }
#line 518
  tmp___0 = i;
#line 518
  i ++;
#line 518
  tmp___1 = old_argv;
#line 518
  old_argv ++;
#line 518
  *(new_argv + tmp___0) = *tmp___1;
#line 520
  if (old_argc > 1) {
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;

#line 522
      if (! (i < old_argc)) {
#line 522
        goto while_break;
      }
#line 523
      tmp___2 = old_argv;
#line 523
      old_argv ++;
#line 523
      arg = *tmp___2;
#line 525
      if ((int )*(arg + 0) != 45) {
#line 526
        tmp___3 = i;
#line 526
        i ++;
#line 526
        *(new_argv + tmp___3) = (char *)"--";
#line 527
        tmp___4 = i;
#line 527
        i ++;
#line 527
        *(new_argv + tmp___4) = arg;
#line 528
        goto while_break;
      }
      {
#line 531
      tmp___5 = i;
#line 531
      i ++;
#line 531
      *(new_argv + tmp___5) = arg;
#line 533
      tmp___8 = should_skip_parameter(arg, longopts);
      }
#line 533
      if (tmp___8) {
#line 533
        if (i < old_argc) {
#line 534
          tmp___6 = i;
#line 534
          i ++;
#line 534
          tmp___7 = old_argv;
#line 534
          old_argv ++;
#line 534
          *(new_argv + tmp___6) = *tmp___7;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: ;
    {
#line 538
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 538
      if (! *old_argv) {
#line 538
        goto while_break___0;
      }
#line 539
      tmp___9 = i;
#line 539
      i ++;
#line 539
      tmp___10 = old_argv;
#line 539
      old_argv ++;
#line 539
      *(new_argv + tmp___9) = *tmp___10;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
  }
#line 542
  *new_argc = i;
#line 543
  return (new_argv);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void read_args(int orig_argc , char **orig_argv ) 
{ 
  char **argv ;
  int argc ;
  int skip_args ;
  struct option longopts[10] ;
  int c ;
  void *__cil_tmp8 ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 554
  skip_args = 0;
#line 556
  longopts[0].name = "help";
#line 556
  longopts[0].has_arg = 0;
#line 556
  longopts[0].flag = (int *)0;
#line 556
  longopts[0].val = 'h';
#line 556
  longopts[1].name = "version";
#line 556
  longopts[1].has_arg = 0;
#line 556
  longopts[1].flag = (int *)0;
#line 556
  longopts[1].val = 'v';
#line 556
  longopts[2].name = "sbox-call";
#line 556
  longopts[2].has_arg = 0;
#line 556
  longopts[2].flag = & skip_args;
#line 556
  longopts[2].val = 1;
#line 556
  longopts[3].name = "target";
#line 556
  longopts[3].has_arg = 1;
#line 556
  longopts[3].flag = (int *)0;
#line 556
  longopts[3].val = 't';
#line 556
  longopts[4].name = "config";
#line 556
  longopts[4].has_arg = 1;
#line 556
  longopts[4].flag = (int *)0;
#line 556
  longopts[4].val = 'c';
#line 556
  longopts[5].name = "directory";
#line 556
  longopts[5].has_arg = 1;
#line 556
  longopts[5].flag = (int *)0;
#line 556
  longopts[5].val = 'd';
#line 556
  longopts[6].name = "remote";
#line 556
  longopts[6].has_arg = 1;
#line 556
  longopts[6].flag = (int *)0;
#line 556
  longopts[6].val = 'r';
#line 556
  longopts[7].name = "mount";
#line 556
  longopts[7].has_arg = 0;
#line 556
  longopts[7].flag = & action;
#line 556
  longopts[7].val = 49;
#line 556
  longopts[8].name = "umount";
#line 556
  longopts[8].has_arg = 0;
#line 556
  longopts[8].flag = & action;
#line 556
  longopts[8].val = 50;
#line 556
  longopts[9].name = (char const   *)0;
#line 556
  longopts[9].has_arg = 0;
#line 556
  longopts[9].flag = (int *)0;
#line 556
  longopts[9].val = 0;
#line 569
  argv = modify_args(orig_argc, orig_argv, & argc, longopts);
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 574
    c = getopt_long(argc, (char * const  *)argv, "hvt:c:d:r:", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 575
    if (c < 0) {
#line 576
      goto while_break;
    }
#line 580
    if (c == 116) {
#line 580
      goto case_116;
    }
#line 584
    if (c == 99) {
#line 584
      goto case_99;
    }
#line 588
    if (c == 100) {
#line 588
      goto case_100;
    }
#line 592
    if (c == 114) {
#line 592
      goto case_114;
    }
#line 596
    if (c == 0) {
#line 596
      goto case_0;
    }
#line 600
    if (c == 118) {
#line 600
      goto case_118;
    }
#line 605
    if (c == 104) {
#line 605
      goto case_104;
    }
#line 609
    goto switch_default;
    case_116: 
#line 581
    target = optarg;
#line 582
    goto switch_break;
    case_99: 
#line 585
    configpath = optarg;
#line 586
    goto switch_break;
    case_100: 
#line 589
    cwd = optarg;
#line 590
    goto switch_break;
    case_114: 
#line 593
    remote_user = optarg;
#line 594
    goto switch_break;
    case_0: 
#line 598
    goto switch_break;
    case_118: 
    {
#line 601
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Scratchbox Remote Shell client %d%s\n",
            7, ".6");
#line 603
    exit(0);
    }
    case_104: 
    {
#line 606
    usage();
#line 607
    exit(0);
    }
    switch_default: 
    {
#line 610
    usage();
#line 611
    exit(1);
    }
    switch_break: ;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 615
  if (*(argv + optind)) {
#line 615
    if (*(argv + (optind + skip_args))) {
#line 616
      args = argv + (optind + skip_args);
    }
  }
#line 617
  return;
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static void cleanup(void) 
{ 
  bool_t tmp ;
  bool_t tmp___0 ;

  {
  {
#line 626
  tmp = buf_is_empty(buf_out);
  }
#line 626
  if (! tmp) {
    {
#line 627
    set_nonblocking(1, (bool_t )0);
#line 628
    write_buffer(buf_out, 1, & outwait);
    }
  }
  {
#line 631
  tmp___0 = buf_is_empty(buf_err);
  }
#line 631
  if (! tmp___0) {
    {
#line 632
    set_nonblocking(2, (bool_t )0);
#line 633
    write_buffer(buf_err, 2, & errwait);
    }
  }
  {
#line 636
  set_old_mode();
  }
#line 639
  return;
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
static int determine_user_info(uid_t *uidp , gid_t *gidp , char *username ) 
{ 
  uid_t uid ;
  gid_t gid ;
  int tmp ;
  char *str ;
  struct passwd *userstruct ;
  struct passwd *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 646
  if ((unsigned long )remote_user != (unsigned long )((void *)0)) {
    {
#line 651
    tmp = sscanf((char const   */* __restrict  */)((char const   *)remote_user), (char const   */* __restrict  */)"%d,%d,%s",
                 & uid, & gid, username);
    }
#line 651
    if (tmp != 3) {
      {
#line 652
      error("Invalid format for -r argument: %s", remote_user);
      }
#line 653
      return (1);
    }
  } else {
    {
#line 659
    uid = geteuid();
#line 660
    gid = getegid();
#line 662
    tmp___0 = getpwuid(uid);
#line 662
    userstruct = tmp___0;
    }
#line 663
    if (! userstruct) {
      {
#line 664
      error("Can\'t get user information about uid %d", uid);
      }
#line 665
      return (1);
    }
    {
#line 668
    strcpy((char */* __restrict  */)username, (char const   */* __restrict  */)((char const   *)userstruct->pw_name));
#line 673
    str = getenv("_SBOX_NONFAKE_USER");
    }
#line 674
    if (str) {
      {
#line 675
      strcpy((char */* __restrict  */)username, (char const   */* __restrict  */)((char const   *)str));
      }
    }
    {
#line 678
    str = getenv("_SBOX_NONFAKE_UID");
    }
#line 679
    if (str) {
      {
#line 679
      tmp___1 = atoi((char const   *)str);
#line 679
      uid = (uid_t )tmp___1;
      }
#line 679
      if (uid <= 0U) {
        {
#line 680
        error("Invalid _SBOX_NONFAKE_UID: %d", uid);
        }
#line 681
        return (1);
      }
    }
    {
#line 684
    str = getenv("_SBOX_NONFAKE_GID");
    }
#line 685
    if (str) {
      {
#line 685
      tmp___2 = atoi((char const   *)str);
#line 685
      gid = (gid_t )tmp___2;
      }
#line 685
      if (gid <= 0U) {
        {
#line 686
        error("Invalid _SBOX_NONFAKE_GID: %d", gid);
        }
#line 687
        return (1);
      }
    }
  }
#line 691
  *uidp = uid;
#line 692
  *gidp = gid;
#line 694
  return (0);
}
}
#line 700 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/client.c"
int main(int argc , char **argv ) 
{ 
  config_t *cfg ;
  mount_info_t **mounts ;
  int16_t rc ;
  uid_t uid ;
  gid_t gid ;
  char user[255] ;
  void *tmp ;
  struct sigaction act ;
  char *home ;
  char *path ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  bool_t tmp___3 ;
  size_t len ;
  size_t i ;
  void *tmp___4 ;
  mount_info_t *mi ;
  mount_info_t *tmp___5 ;
  int tmp___6 ;
  struct addrinfo *ai ;
  struct addrinfo *i___0 ;
  struct addrinfo hints ;
  char *port___0 ;
  int ret ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  uint16_t val ;
  ptype_t type ;
  int tmp___13 ;
  uint16_t auth ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  bool_t is_tty ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  gid_t gids[65536] ;
  int num ;
  int i___1 ;
  uint16v_t *ids ;
  int tmp___26 ;
  int tmp___27 ;
  uint16_t mask ;
  __mode_t tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct winsize ws ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  uint16_t val___0 ;
  ptype_t type___0 ;
  int tmp___43 ;
  int tmp___44 ;
  int *tmp___45 ;
  void *__cil_tmp79 ;
  void *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;

  {
  {
#line 705
  uid = (uid_t )0;
#line 706
  gid = (gid_t )0;
#line 709
  progname = get_progname(*(argv + 0));
#line 717
  cfg = config_alloc();
  }
#line 717
  if (cfg) {
    {
#line 717
    buf_out = buf_alloc();
    }
#line 717
    if (buf_out) {
      {
#line 717
      buf_err = buf_alloc();
      }
#line 717
      if (buf_err) {
        {
#line 717
        tmp = malloc((size_t )4096);
#line 717
        tmp_buf = (char *)tmp;
        }
#line 717
        if (! tmp_buf) {
          {
#line 721
          oom_error();
          }
#line 722
          return (1);
        }
      } else {
        {
#line 721
        oom_error();
        }
#line 722
        return (1);
      }
    } else {
      {
#line 721
      oom_error();
      }
#line 722
      return (1);
    }
  } else {
    {
#line 721
    oom_error();
    }
#line 722
    return (1);
  }
  {
#line 731
  act.__sigaction_handler.sa_handler = (void (*)(int  ))(& exit);
#line 732
  sigemptyset(& act.sa_mask);
#line 733
  act.sa_flags = (-0x7FFFFFFF-1);
#line 735
  sigaction(2, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& act)),
            (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
#line 736
  sigaction(1, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& act)),
            (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
#line 737
  sigaction(15, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& act)),
            (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
#line 739
  atexit(& cleanup);
#line 746
  read_args(argc, argv);
#line 752
  path = (char *)((void *)0);
  }
#line 754
  if (! configpath) {
    {
#line 755
    home = getenv("HOME");
#line 756
    tmp___0 = strlen((char const   *)home);
#line 756
    tmp___1 = strlen("/.sbrsh");
#line 756
    tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
#line 756
    path = (char *)tmp___2;
    }
#line 757
    if (! path) {
      {
#line 758
      oom_error();
      }
#line 759
      return (1);
    }
    {
#line 761
    strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)((char const   *)home));
#line 762
    strcat((char */* __restrict  */)path, (char const   */* __restrict  */)"/.sbrsh");
#line 764
    configpath = path;
    }
  }
  {
#line 767
  tmp___3 = config_read(cfg, (char const   *)configpath, (char const   *)target);
  }
#line 767
  if (! tmp___3) {
#line 768
    if (target) {
      {
#line 769
      error("Target %s not found in %s", target, configpath);
      }
    } else {
      {
#line 771
      error("No targets found in %s", configpath);
      }
    }
#line 772
    return (1);
  }
#line 775
  if (path) {
    {
#line 776
    free((void *)path);
#line 777
    configpath = (char *)((void *)0);
    }
  }
  {
#line 787
  len = calc_vec_len((void **)cfg->opts);
#line 789
  tmp___4 = calloc(len + 1UL, sizeof(mount_info_t *));
#line 789
  mounts = (mount_info_t **)tmp___4;
  }
#line 790
  if (! mounts) {
    {
#line 791
    oom_error();
    }
#line 792
    return (1);
  }
#line 795
  i = (size_t )0;
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;

#line 795
    if (! (i < len)) {
#line 795
      goto while_break;
    }
    {
#line 796
    tmp___5 = mntinfo_parse((char const   *)*(cfg->opts + i));
#line 796
    mi = tmp___5;
    }
#line 797
    if (! mi) {
#line 798
      return (1);
    }
#line 803
    if (action == 48) {
#line 803
      if (1U == (unsigned int )mi->type) {
#line 803
        goto _L;
      } else
#line 803
      if (3U == (unsigned int )mi->type) {
        _L: 
        {
#line 805
        tmp___6 = mntinfo_stat_device(mi);
        }
#line 805
        if (tmp___6 < 0) {
#line 806
          return (1);
        }
      }
    }
#line 811
    *(mounts + i) = mi;
#line 795
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: 
#line 819
  hints.ai_flags = 0;
#line 819
  hints.ai_family = 0;
#line 819
  hints.ai_socktype = 0;
#line 819
  hints.ai_protocol = 0;
#line 819
  hints.ai_addrlen = 0U;
#line 819
  hints.ai_addr = (struct sockaddr *)0;
#line 819
  hints.ai_canonname = (char *)0;
#line 819
  hints.ai_next = (struct addrinfo *)0;
#line 820
  port___0 = (char *)"1202";
#line 823
  hints.ai_flags = 32;
#line 824
  hints.ai_socktype = 1;
#line 826
  if (cfg->port) {
#line 827
    port___0 = cfg->port;
  }
  {
#line 829
  ret = getaddrinfo((char const   */* __restrict  */)((char const   *)cfg->host),
                    (char const   */* __restrict  */)((char const   *)port___0), (struct addrinfo  const  */* __restrict  */)((struct addrinfo  const  *)(& hints)),
                    (struct addrinfo **/* __restrict  */)(& ai));
  }
#line 830
  if (ret < 0) {
    {
#line 831
    tmp___7 = gai_strerror(ret);
#line 831
    error("Can\'t resolve host: %s", tmp___7);
    }
#line 832
    return (1);
  }
#line 835
  i___0 = ai;
  {
#line 835
  while (1) {
    while_continue___4: /* CIL Label */ ;

#line 835
    if (! i___0) {
#line 835
      goto while_break___0;
    }
    {
#line 836
    sd = socket(i___0->ai_family, i___0->ai_socktype, i___0->ai_protocol);
    }
#line 838
    if (sd < 0) {
#line 839
      goto __Cont;
    }
    {
#line 841
    tmp___8 = connect(sd, (struct sockaddr  const  *)i___0->ai_addr, i___0->ai_addrlen);
    }
#line 841
    if (tmp___8 == 0) {
#line 842
      goto while_break___0;
    }
    {
#line 844
    close(sd);
#line 845
    sd = -1;
    }
    __Cont: 
#line 835
    i___0 = i___0->ai_next;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: ;
#line 848
  if (sd < 0) {
    {
#line 849
    error("Can\'t connect");
    }
#line 850
    return (1);
  }
  {
#line 853
  freeaddrinfo(ai);
#line 860
  tmp___9 = send_version(sd);
  }
#line 860
  if (tmp___9 < 0) {
    {
#line 861
    error("Can\'t write protocol version packet to socket");
    }
#line 862
    return (1);
  }
  {
#line 865
  daemon_version = get_version(sd);
  }
#line 866
  if (daemon_version < 0) {
    {
#line 867
    error("Can\'t read protocol version packet from socket");
    }
#line 868
    return (1);
  }
#line 871
  if (daemon_version < 6) {
    {
#line 872
    tmp___10 = __errno_location();
#line 872
    *tmp___10 = 0;
#line 873
    error("Server version %d is too old (version %d required)", daemon_version, 6);
    }
#line 875
    return (1);
  }
  {
#line 881
  tmp___11 = determine_user_info(& uid, & gid, user);
  }
#line 881
  if (tmp___11) {
#line 882
    return (1);
  }
  {
#line 891
  tmp___12 = write_str_packet(sd, (ptype_t )34, (char const   *)(user));
  }
#line 891
  if (tmp___12 < 0) {
    {
#line 892
    error("Can\'t send USER packet");
    }
#line 893
    return (1);
  }
  {
#line 900
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: 
    {
#line 902
    tmp___13 = read_enum(sd);
#line 902
    type = (ptype_t )tmp___13;
    }
#line 906
    if ((unsigned int )type == 4294967295U) {
#line 906
      goto case_4294967295;
    }
#line 910
    if ((unsigned int )type == 35U) {
#line 910
      goto case_35;
    }
#line 925
    if ((unsigned int )type == 36U) {
#line 925
      goto case_36;
    }
#line 934
    if ((unsigned int )type == 16U) {
#line 934
      goto case_16;
    }
#line 938
    if ((unsigned int )type == 17U) {
#line 938
      goto case_17;
    }
#line 942
    goto switch_default;
    case_4294967295: 
    {
#line 907
    error("Can\'t read packet type from socket");
    }
#line 908
    return (1);
    case_35: 
    {
#line 912
    tmp___14 = read_uint16(sd, & auth);
    }
#line 912
    if (tmp___14 < 0) {
      {
#line 913
      error("Can\'t read AUTH packet from socket");
      }
#line 914
      return (1);
    }
#line 916
    if (auth) {
#line 918
      goto switch_break;
    } else {
      {
#line 920
      tmp___15 = __errno_location();
#line 920
      *tmp___15 = 0;
#line 921
      error("Authentication failed");
      }
#line 922
      return (1);
    }
    case_36: 
    {
#line 927
    tmp___16 = read_uint16(sd, & val);
    }
#line 927
    if (tmp___16 < 0) {
      {
#line 928
      error("Can\'t read RC packet from socket");
      }
#line 929
      return (1);
    }
#line 931
    rc = (int16_t )val;
#line 932
    goto switch_break;
    case_16: 
    {
#line 935
    receive_message((ptype_t )16);
    }
#line 936
    goto while_continue___1;
    case_17: 
    {
#line 939
    receive_message((ptype_t )17);
    }
#line 940
    goto while_continue___1;
    switch_default: 
    {
#line 943
    tmp___17 = __errno_location();
#line 943
    *tmp___17 = 0;
#line 944
    error("Received packet has unexpected type (0x%02x)", (unsigned int )type);
    }
#line 945
    return (1);
    switch_break: ;
#line 948
    goto while_break___1;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: 
  {
#line 955
  tmp___18 = write_str_packet(sd, (ptype_t )65, (char const   *)cfg->target);
  }
#line 955
  if (tmp___18 < 0) {
    {
#line 956
    error("Can\'t send TARGET packet");
    }
#line 957
    return (1);
  }
  {
#line 960
  config_free(cfg);
#line 966
  tmp___19 = write_enum(sd, 66);
  }
#line 966
  if (tmp___19 < 0) {
    {
#line 967
    error("Can\'t send MOUNTS packet");
    }
#line 968
    return (1);
  } else {
    {
#line 966
    tmp___20 = write_mountv(sd, mounts);
    }
#line 966
    if (tmp___20 < 0) {
      {
#line 967
      error("Can\'t send MOUNTS packet");
      }
#line 968
      return (1);
    }
  }
#line 975
  if (action == 48) {
#line 981
    if (args) {
      {
#line 983
      tmp___21 = write_enum(sd, 80);
      }
#line 983
      if (tmp___21 < 0) {
        {
#line 984
        error("Can\'t send ARGS packet");
        }
#line 985
        return (1);
      } else {
        {
#line 983
        tmp___22 = write_strv(sd, args);
        }
#line 983
        if (tmp___22 < 0) {
          {
#line 984
          error("Can\'t send ARGS packet");
          }
#line 985
          return (1);
        }
      }
    }
#line 992
    if (cwd) {
      {
#line 994
      tmp___23 = write_str_packet(sd, (ptype_t )81, (char const   *)cwd);
      }
#line 994
      if (tmp___23 < 0) {
        {
#line 995
        error("Can\'t send CWD packet");
        }
#line 996
        return (1);
      }
    }
    {
#line 1005
    tmp___24 = write_enum(sd, 82);
    }
#line 1005
    if (tmp___24 < 0) {
      {
#line 1006
      error("Can\'t send ENVIRON packet");
      }
#line 1007
      return (1);
    } else {
      {
#line 1005
      tmp___25 = write_strv(sd, environ);
      }
#line 1005
      if (tmp___25 < 0) {
        {
#line 1006
        error("Can\'t send ENVIRON packet");
        }
#line 1007
        return (1);
      }
    }
#line 1021
    if (! remote_user) {
      {
#line 1022
      num = getgroups(65536, gids);
      }
#line 1023
      if (num < 0) {
        {
#line 1024
        error("Can\'t get supplementary group IDs");
        }
#line 1025
        return (1);
      }
    } else {
#line 1028
      num = 0;
    }
    {
#line 1031
    ids = uint16v_alloc((uint32_t )(2 + num));
    }
#line 1032
    if (! ids) {
      {
#line 1033
      oom_error();
      }
#line 1034
      return (1);
    }
#line 1037
    *(ids->vec + 0) = (uint16_t )uid;
#line 1038
    *(ids->vec + 1) = (uint16_t )gid;
#line 1040
    i___1 = 0;
    {
#line 1040
    while (1) {
      while_continue___6: /* CIL Label */ ;

#line 1040
      if (! (i___1 < num)) {
#line 1040
        goto while_break___2;
      }
#line 1041
      *(ids->vec + (i___1 + 2)) = (uint16_t )gids[i___1];
#line 1040
      i___1 ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: 
    {
#line 1044
    tmp___26 = write_enum(sd, 83);
    }
#line 1044
    if (tmp___26 < 0) {
      {
#line 1045
      error("Can\'t send IDS packet");
      }
#line 1046
      return (1);
    } else {
      {
#line 1044
      tmp___27 = write_uint16v(sd, ids);
      }
#line 1044
      if (tmp___27 < 0) {
        {
#line 1045
        error("Can\'t send IDS packet");
        }
#line 1046
        return (1);
      }
    }
    {
#line 1049
    uint16v_free(ids);
#line 1056
    tmp___28 = umask((__mode_t )0);
#line 1056
    mask = (uint16_t )tmp___28;
#line 1057
    umask((__mode_t )mask);
#line 1060
    tmp___29 = write_uint16_packet(sd, (ptype_t )84, mask);
    }
#line 1060
    if (tmp___29 < 0) {
      {
#line 1061
      error("Can\'t send UMASK packet");
      }
#line 1062
      return (1);
    }
    {
#line 1070
    tmp___30 = isatty(0);
    }
#line 1070
    if (tmp___30) {
      {
#line 1070
      tmp___31 = isatty(1);
      }
#line 1070
      if (tmp___31) {
        {
#line 1070
        tmp___32 = isatty(2);
        }
#line 1070
        if (tmp___32) {
#line 1070
          tmp___33 = 1;
        } else {
#line 1070
          tmp___33 = 0;
        }
      } else {
#line 1070
        tmp___33 = 0;
      }
    } else {
#line 1070
      tmp___33 = 0;
    }
#line 1070
    is_tty = (bool_t )tmp___33;
#line 1073
    if (is_tty) {
      {
#line 1075
      ioctl(0, 21523UL, & ws);
#line 1078
      tmp___34 = write_enum(sd, 85);
      }
#line 1078
      if (tmp___34 < 0) {
        {
#line 1079
        error("Can\'t send WINSIZE packet");
        }
#line 1080
        return (1);
      } else {
        {
#line 1078
        tmp___35 = write_winsize(sd, (struct winsize  const  *)(& ws));
        }
#line 1078
        if (tmp___35 < 0) {
          {
#line 1079
          error("Can\'t send WINSIZE packet");
          }
#line 1080
          return (1);
        }
      }
    }
    {
#line 1088
    tmp___36 = set_nonblocking(1, (bool_t )1);
    }
#line 1088
    if (tmp___36 < 0) {
      {
#line 1089
      error("Can\'t make stdout non-blocking");
      }
#line 1090
      return (1);
    }
#line 1093
    if (is_tty) {
      {
#line 1094
      tmp___37 = set_nonblocking(2, (bool_t )1);
      }
#line 1094
      if (tmp___37 < 0) {
        {
#line 1095
        error("Can\'t make stderr non-blocking");
        }
#line 1096
        return (1);
      }
      {
#line 1099
      tmp___38 = set_raw_mode();
      }
#line 1099
      if (tmp___38 < 0) {
#line 1100
        return (1);
      }
    }
    {
#line 1107
    tmp___39 = write_enum(sd, 48);
    }
#line 1107
    if (tmp___39 < 0) {
      {
#line 1108
      error("Can\'t send COMMAND packet");
      }
#line 1109
      return (1);
    }
    {
#line 1115
    tmp___40 = manage(is_tty);
#line 1115
    rc = (int16_t )tmp___40;
    }
#line 1116
    if ((int )rc < 0) {
#line 1117
      return (1);
    }
  } else {
#line 1124
    if (action == 49) {
      {
#line 1126
      tmp___41 = write_enum(sd, 49);
      }
#line 1126
      if (tmp___41 < 0) {
        {
#line 1127
        error("Can\'t send MOUNT packet");
        }
#line 1128
        return (1);
      }
    } else {
      {
#line 1132
      tmp___42 = write_enum(sd, 50);
      }
#line 1132
      if (tmp___42 < 0) {
        {
#line 1133
        error("Can\'t send UMOUNT packet");
        }
#line 1134
        return (1);
      }
    }
    {
#line 1141
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___3: 
      {
#line 1143
      tmp___43 = read_enum(sd);
#line 1143
      type___0 = (ptype_t )tmp___43;
      }
#line 1145
      if ((unsigned int )type___0 == 4294967295U) {
#line 1145
        goto case_4294967295___0;
      }
#line 1149
      if ((unsigned int )type___0 == 36U) {
#line 1149
        goto case_36___0;
      }
#line 1158
      if ((unsigned int )type___0 == 16U) {
#line 1158
        goto case_16___0;
      }
#line 1162
      if ((unsigned int )type___0 == 17U) {
#line 1162
        goto case_17___0;
      }
#line 1166
      goto switch_default___0;
      case_4294967295___0: 
      {
#line 1146
      error("Can\'t read packet type from socket");
      }
#line 1147
      return (1);
      case_36___0: 
      {
#line 1151
      tmp___44 = read_uint16(sd, & val___0);
      }
#line 1151
      if (tmp___44 < 0) {
        {
#line 1152
        error("Can\'t read RC packet from socket");
        }
#line 1153
        return (1);
      }
#line 1155
      rc = (int16_t )val___0;
#line 1156
      goto switch_break___0;
      case_16___0: 
      {
#line 1159
      receive_message((ptype_t )16);
      }
#line 1160
      goto while_continue___3;
      case_17___0: 
      {
#line 1163
      receive_message((ptype_t )17);
      }
#line 1164
      goto while_continue___3;
      switch_default___0: 
      {
#line 1167
      tmp___45 = __errno_location();
#line 1167
      *tmp___45 = 0;
#line 1168
      error("Received packet has unexpected type (0x%02x)", (unsigned int )type___0);
      }
#line 1169
      return (1);
      switch_break___0: ;
#line 1172
      goto while_break___3;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: ;
  }
#line 1180
  if ((int )rc == 32767) {
#line 1182
    return (1);
  } else {
#line 1185
    return ((int )rc);
  }
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.h"
mount_info_t *mntinfo_alloc(void) ;
#line 66
void mntinfo_free(mount_info_t *mi ) ;
#line 67
int mntinfo_copy(mount_info_t *dest , mount_info_t *src ) ;
#line 70
void mntinfo_sort_vec(mount_info_t **vec ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
uint32_t resolve(char const   *hostname ) ;
#line 40
ssize_t read_line(FILE *file , char *buf , size_t size ) ;
#line 47
int split_string(char *line  , ...) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
mount_info_t *mntinfo_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 20
  tmp = calloc((size_t )1, sizeof(mount_info_t ));
  }
#line 20
  return ((mount_info_t *)tmp);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
void mntinfo_free(mount_info_t *mi ) 
{ 


  {
  {

#line 25
  if (mi->opts) {
    {
#line 26
    free((void *)mi->opts);
    }
  }
  }
  {
#line 28
  airac_observe(mi, 0);
#line 28
  if (mi->device) {
    {
#line 29
    free((void *)mi->device);
    }
  }
  }
#line 31
  if (mi->point) {
    {
#line 32
    free((void *)mi->point);
    }
  }
  {
#line 34
  free((void *)mi);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
int mntinfo_copy(mount_info_t *dest , mount_info_t *src ) 
{ 


  {
  {
#line 39
  memset((void *)dest, 0, sizeof(mount_info_t ));
#line 41
  dest->type = src->type;
#line 43
  dest->point = strdup((char const   *)src->point);
  }
#line 44
  if (! dest->point) {
#line 45
    goto _err;
  }
  {
#line 47
  dest->device = strdup((char const   *)src->device);
  }
#line 48
  if (! dest->device) {
#line 49
    goto _err;
  }
#line 51
  if (src->opts) {
    {
#line 52
    dest->opts = strdup((char const   *)src->opts);
    }
#line 53
    if (! dest->opts) {
#line 54
      goto _err;
    }
  }
#line 57
  dest->device_dev = src->device_dev;
#line 59
  return (0);
  _err: 
#line 62
  if (dest->device) {
    {
#line 63
    free((void *)dest->device);
    }
  }
#line 65
  if (dest->point) {
    {
#line 66
    free((void *)dest->point);
    }
  }
  {
#line 68
  oom_error();
  }
#line 69
  return (-1);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
mount_info_t *mntinfo_parse(char const   *input ) 
{ 
  mount_info_t *mi ;
  char *buf ;
  char *type ;
  char *device ;
  char *point ;
  char *opts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 79
  buf = (char *)((void *)0);
#line 81
  mi = mntinfo_alloc();
  }
#line 82
  if (! mi) {
    {
#line 83
    oom_error();
    }
#line 84
    return ((mount_info_t *)((void *)0));
  }
  {
#line 87
  buf = strdup(input);
  }
#line 88
  if (! buf) {
    {
#line 89
    oom_error();
    }
#line 90
    goto _err_buf;
  }
  {
#line 93
  split_string(buf, & type, & device, & point, & opts, (void *)0);
  }
#line 95
  if (! type) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  } else
#line 95
  if (! device) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  } else
#line 95
  if (! point) {
    {
#line 96
    error("Invalid mount entry: %s", input);
    }
#line 97
    goto _err;
  }
  {
#line 100
  tmp___1 = strcmp((char const   *)type, "nfs");
  }
#line 100
  if (tmp___1 == 0) {
#line 101
    mi->type = (mtype_t )1;
  } else {
    {
#line 102
    tmp___0 = strcmp((char const   *)type, "bind");
    }
#line 102
    if (tmp___0 == 0) {
#line 103
      mi->type = (mtype_t )2;
    } else {
      {
#line 104
      tmp = strcmp((char const   *)type, "ssh");
      }
#line 104
      if (tmp == 0) {
#line 105
        mi->type = (mtype_t )3;
      } else {
        {
#line 107
        error("Unknown mount type: %s", type);
        }
#line 108
        goto _err;
      }
    }
  }
  {
#line 111
  mi->device = strdup((char const   *)device);
  }
#line 112
  if (! mi->device) {
    {
#line 113
    oom_error();
    }
#line 114
    goto _err;
  }
  {
#line 117
  mi->point = strdup((char const   *)point);
  }
#line 118
  if (! mi->point) {
    {
#line 119
    oom_error();
    }
#line 120
    goto _err;
  }
#line 123
  if (opts) {
    {
#line 124
    mi->opts = strdup((char const   *)opts);
    }
#line 125
    if (! mi->opts) {
      {
#line 126
      oom_error();
      }
#line 127
      goto _err;
    }
  }
  {
#line 131
  free((void *)buf);
  }
#line 133
  return (mi);
  _err: 
  {
#line 136
  free((void *)buf);
  }
  _err_buf: 
  {
#line 139
  mntinfo_free(mi);
  }
#line 140
  return ((mount_info_t *)((void *)0));
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static int resolve_nfs(char const   *fs , uint32_t *addr_p , char **path_p ) 
{ 
  char host[64] ;
  char *path ;
  uint32_t addr ;
  unsigned long tmp ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 153
  path = strchr(fs, ':');
  }
#line 154
  if (! path) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  } else
#line 154
  if ((int )*(path + 1) == 0) {
    {
#line 155
    error("Invalid NFS filesystem: %s", fs);
    }
#line 156
    return (-1);
  }
  {
#line 159
  memset((void *)(host), '\000', sizeof(host));
  }
#line 160
  if ((unsigned long )(path - (char *)fs) < sizeof(host) - 1UL) {
#line 160
    tmp = (unsigned long )(path - (char *)fs);
  } else {
#line 160
    tmp = sizeof(host) - 1UL;
  }
  {
#line 160
  strncpy((char */* __restrict  */)(host), (char const   */* __restrict  */)fs, tmp);
#line 162
  addr = resolve((char const   *)(host));
  }
#line 163
  if (! addr) {
#line 164
    return (-1);
  }
#line 166
  *addr_p = addr;
#line 167
  *path_p = path + 1;
#line 169
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *get_local_path(uint32_t r_addr , char *r_path ) 
{ 
  FILE *file ;
  char buf[1024] ;
  struct __anonstruct_sel_57 sel ;
  char *device ;
  char *point ;
  char *type ;
  char *nfs_path ;
  uint32_t nfs_addr ;
  ssize_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 182
  sel.path = (char *)((void *)0);
#line 184
  file = fopen((char const   */* __restrict  */)"/proc/mounts", (char const   */* __restrict  */)"r");
  }
#line 185
  if (! file) {
    {
#line 186
    error("Can\'t open /proc/mounts");
    }
#line 187
    return ((char *)((void *)0));
  }
  {
#line 190
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 194
    tmp = read_line(file, buf, sizeof(buf));
    }
#line 194
    if (tmp < 0L) {
#line 195
      goto while_break;
    }
    {
#line 197
    split_string(buf, & device, & point, & type, (void *)0);
    }
#line 198
    if (! device) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! point) {
#line 199
      goto while_continue;
    } else
#line 198
    if (! type) {
#line 199
      goto while_continue;
    } else {
      {
#line 198
      tmp___0 = strchr((char const   *)device, ':');
      }
#line 198
      if (tmp___0) {
        {
#line 198
        tmp___1 = strcmp((char const   *)type, "nfs");
        }
#line 198
        if (tmp___1 != 0) {
#line 199
          goto while_continue;
        }
      } else {
#line 199
        goto while_continue;
      }
    }
    {
#line 201
    tmp___2 = resolve_nfs((char const   *)device, & nfs_addr, & nfs_path);
    }
#line 201
    if (tmp___2 < 0) {
#line 202
      goto _err;
    }
#line 204
    if (r_addr != nfs_addr) {
#line 205
      goto while_continue;
    }
    {
#line 207
    tmp___3 = strlen((char const   *)nfs_path);
#line 207
    tmp___4 = strncmp((char const   *)r_path, (char const   *)nfs_path, tmp___3);
    }
#line 207
    if (tmp___4 != 0) {
#line 208
      goto while_continue;
    }
#line 212
    if (sel.path) {
      {
#line 213
      tmp___5 = strlen((char const   *)(sel.nfs_path));
#line 213
      tmp___6 = strlen((char const   *)nfs_path);
      }
#line 213
      if (tmp___5 < tmp___6) {
#line 214
        goto while_continue;
      }
      {
#line 216
      free((void *)sel.path);
      }
    }
    {
#line 219
    sel.path = strdup((char const   *)point);
    }
#line 220
    if (! sel.path) {
      {
#line 221
      oom_error();
      }
#line 222
      goto _err;
    }
    {
#line 225
    memset((void *)(sel.nfs_path), '\000', sizeof(sel.nfs_path));
#line 226
    strncpy((char */* __restrict  */)(sel.nfs_path), (char const   */* __restrict  */)((char const   *)nfs_path),
            sizeof(sel.nfs_path) - 1UL);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 229
  fclose(file);
  }
#line 231
  if (sel.path) {
#line 232
    return (sel.path);
  } else {
#line 234
    return (r_path);
  }
  _err: 
#line 237
  if (sel.path) {
    {
#line 238
    free((void *)sel.path);
    }
  }
  {
#line 240
  fclose(file);
  }
#line 242
  return ((char *)((void *)0));
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
static char *scratchbox_path_alias(char const   * const  path ) 
{ 
  char const   *scratchbox ;
  size_t scratchbox_len ;
  size_t tmp ;
  char *alias ;
  char *renamed ;
  size_t alias_len ;
  size_t renamed_len ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 247
  scratchbox = "/scratchbox/";
#line 248
  tmp = strlen(scratchbox);
#line 248
  scratchbox_len = tmp;
#line 253
  alias = getenv("_SBOX_DIR");
  }
#line 254
  if (! alias) {
#line 255
    return ((char *)((void *)0));
  }
  {
#line 257
  alias_len = strlen((char const   *)alias);
  }
#line 258
  if (alias_len <= 1UL) {
#line 259
    return ((char *)((void *)0));
  } else {
    {
#line 258
    tmp___0 = strncmp((char const   *)path, (char const   *)alias, alias_len);
    }
#line 258
    if (tmp___0 != 0) {
#line 259
      return ((char *)((void *)0));
    }
  }
  {
#line 261
  tmp___1 = strlen((char const   *)path);
#line 261
  renamed_len = ((tmp___1 - alias_len) + scratchbox_len) + 1UL;
#line 262
  tmp___2 = malloc(renamed_len);
#line 262
  renamed = (char *)tmp___2;
  }
#line 263
  if (! renamed) {
    {
#line 264
    oom_error();
    }
#line 265
    return ((char *)((void *)0));
  }
  {
#line 268
  strcpy((char */* __restrict  */)renamed, (char const   */* __restrict  */)scratchbox);
#line 269
  strcat((char */* __restrict  */)renamed, (char const   */* __restrict  */)((char const   *)(path + alias_len)));
  }
#line 271
  return (renamed);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
int mntinfo_stat_device(mount_info_t *mi ) 
{ 
  char *nfs_path ;
  char *path ;
  char *renamed_path ;
  uint32_t nfs_addr ;
  struct stat buf ;
  int rc ;
  int tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 279
  nfs_path = (char *)((void *)0);
#line 284
  if ((unsigned int )mi->type == 1U) {
    {
#line 285
    tmp = resolve_nfs((char const   *)mi->device, & nfs_addr, & nfs_path);
    }
#line 285
    if (tmp < 0) {
#line 286
      return (-1);
    }
    {
#line 288
    path = get_local_path(nfs_addr, nfs_path);
    }
#line 289
    if (! path) {
#line 290
      return (-1);
    }
    {
#line 292
    renamed_path = scratchbox_path_alias((char const   */* const  */)((char const   *)path));
    }
#line 293
    if (renamed_path) {
#line 294
      if ((unsigned long )path != (unsigned long )nfs_path) {
        {
#line 295
        free((void *)path);
        }
      }
#line 297
      path = renamed_path;
    }
  } else {
    {
#line 300
    path = strchr((char const   *)mi->device, ':');
    }
#line 301
    if (! path) {
#line 302
      return (-1);
    }
#line 303
    path ++;
  }
  {
#line 306
  rc = stat((char const   */* __restrict  */)((char const   *)path), (struct stat */* __restrict  */)(& buf));
  }
#line 307
  if (rc >= 0) {
#line 308
    mi->device_dev = buf.st_dev;
  } else {
    {
#line 310
    error("Can\'t stat %s", path);
    }
  }
#line 312
  if (nfs_path) {
#line 312
    if ((unsigned long )path != (unsigned long )nfs_path) {
      {
#line 313
      free((void *)path);
      }
    }
  }
#line 315
  return (rc);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/mount.c"
void mntinfo_sort_vec(mount_info_t **vec ) 
{ 
  mount_info_t **p ;
  mount_info_t *tmp ;
  bool_t touched ;
  int tmp___0 ;

  {
#line 326
  if (! *(vec + 0)) {
#line 327
    return;
  } else
#line 326
  if (! *(vec + 1)) {
#line 327
    return;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    touched = (bool_t )0;
#line 332
    p = vec;
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 332
      if (! *(p + 1)) {
#line 332
        goto while_break___0;
      }
      {
#line 333
      tmp___0 = strcmp((char const   *)(*(p + 0))->point, (char const   *)(*(p + 1))->point);
      }
#line 333
      if (tmp___0 > 0) {
#line 334
        tmp = *(p + 0);
#line 335
        *(p + 0) = *(p + 1);
#line 336
        *(p + 1) = tmp;
#line 338
        touched = (bool_t )1;
      }
#line 332
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: ;
#line 329
    if (! touched) {
#line 329
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 342
  return;
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.h"
int set_closeonexec(int fd ) ;
#line 35
int setsockopt_bool(int s , int level , int sockopt , bool_t value ) ;
#line 38
void free_vec(void **vec , free_func_t *func ) ;
#line 41
ssize_t read_line_blank(FILE *file , char *buf , size_t size , bool_t *blankp ) ;
#line 42
ssize_t read_line_nocomments(FILE *file , char *buf , size_t size ) ;
#line 43
char *skip_spaces(char const   *buf ) ;
#line 44
char *find_space(char const   *buf ) ;
#line 45
char *find_line(char *buf ) ;
#line 46
char *trim_string(char *buf ) ;
#line 48
size_t string_cat(char *buf , size_t bufsize , char const   *piece  , ...) ;
#line 51
char const   *oom ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char const   *oom  =    "Out of memory";
#line 24 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
void oom_error(void) 
{ 
  int *tmp ;

  {
  {
#line 26
  tmp = __errno_location();
#line 26
  *tmp = 0;
#line 27
  error(oom);
  }
#line 28
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int set_nonblocking(int fd , bool_t nonblock ) 
{ 
  int val ;
  int tmp ;

  {
  {
#line 39
  val = fcntl(fd, 3, 0);
  }
#line 40
  if (val < 0) {
#line 41
    return (-1);
  }
#line 43
  if (nonblock) {
#line 44
    if (val & 2048) {
#line 45
      return (0);
    }
#line 47
    val |= 2048;
  } else {
#line 49
    if (! (val & 2048)) {
#line 50
      return (0);
    }
#line 52
    val &= -2049;
  }
  {
#line 55
  tmp = fcntl(fd, 4, val);
  }
#line 55
  return (tmp);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int set_closeonexec(int fd ) 
{ 
  int val ;
  int tmp ;

  {
  {
#line 65
  val = fcntl(fd, 1, 0);
  }
#line 66
  if (val < 0) {
#line 67
    return (-1);
  }
#line 69
  if (val & 1) {
#line 70
    return (0);
  }
  {
#line 72
  tmp = fcntl(fd, 2, val | 1);
  }
#line 72
  return (tmp);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int setsockopt_bool(int s , int level , int sockopt , bool_t value ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = setsockopt(s, level, sockopt, (void const   *)(& value), (socklen_t )sizeof(value));
  }
#line 77
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *get_progname(char *name ) 
{ 
  char *p ;
  size_t tmp ;

  {
  {
#line 87
  p = strrchr((char const   *)name, '/');
  }
#line 88
  if (p) {
    {
#line 88
    tmp = strlen((char const   *)p);
    }
#line 88
    if (tmp >= 2UL) {
#line 89
      return (p + 1);
    } else {
#line 91
      return (name);
    }
  } else {
#line 91
    return (name);
  }
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
uint32_t resolve(char const   *hostname ) 
{ 
  struct hostent *host ;
  uint32_t addr ;
  uint32_t tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 99
  host = gethostbyname(hostname);
  }
#line 100
  if (! host) {
#line 101
    goto _err;
  }
#line 103
  addr = *((uint32_t *)*(host->h_addr_list + 0));
#line 104
  if (! addr) {
#line 105
    goto _err;
  }
  {
#line 107
  tmp = ntohl(addr);
  }
#line 107
  return (tmp);
  _err: 
  {
#line 110
  error("Can\'t resolve host: %s", hostname);
  }
#line 111
  return ((uint32_t )0);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
void free_vec(void **vec , free_func_t *func ) 
{ 
  void **p ;

  {
#line 125
  if (! vec) {
#line 126
    return;
  }
#line 128
  if (! func) {
#line 129
    func = (free_func_t *)(& free);
  }
#line 131
  p = vec;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;

#line 131
    if (! *p) {
#line 131
      goto while_break;
    }
    {
#line 132
    (*func)(*p);
#line 131
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 134
  free((void *)vec);
  }
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
size_t calc_vec_len(void **vec ) 
{ 
  size_t len ;
  void **tmp ;

  {
#line 139
  len = (size_t )0;
#line 141
  if (vec) {
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 142
      tmp = vec;
#line 142
      vec ++;
#line 142
      if (! *tmp) {
#line 142
        goto while_break;
      }
#line 143
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 145
  return (len);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
static ssize_t do_read_line(FILE *file , char *buf , size_t size , char comment_char ,
                            bool_t *blankp ) 
{ 
  bool_t blank ;
  bool_t comm ;
  size_t i ;
  int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 151
  blank = (bool_t )1;
#line 152
  comm = (bool_t )0;
#line 153
  i = (size_t )0;
#line 156
  tmp = feof(file);
  }
#line 156
  if (tmp) {
#line 157
    return ((ssize_t )-1);
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    c = fgetc(file);
    }
#line 161
    if (c == -1) {
#line 162
      goto while_break;
    } else
#line 161
    if (c == 10) {
#line 162
      goto while_break;
    }
    {
#line 164
    tmp___0 = __ctype_b_loc();
    }
#line 164
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 165
      blank = (bool_t )0;
    }
#line 167
    if (c == (int )comment_char) {
#line 168
      comm = (bool_t )1;
    }
#line 170
    if (! comm) {
#line 170
      if (i < size - 1UL) {
#line 171
        tmp___1 = buf;
#line 171
        buf ++;
#line 171
        *tmp___1 = (char )c;
#line 172
        i ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
#line 175
  *buf = (char )'\000';
#line 177
  if (blankp) {
#line 178
    *blankp = blank;
  }
#line 180
  return ((ssize_t )i);
}
}
#line 183 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line(FILE *file , char *buf , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 185
  tmp = do_read_line(file, buf, size, (char )'#', (bool_t *)((void *)0));
  }
#line 185
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line_blank(FILE *file , char *buf , size_t size , bool_t *blankp ) 
{ 
  ssize_t tmp ;

  {
  {
#line 190
  tmp = do_read_line(file, buf, size, (char )'#', blankp);
  }
#line 190
  return (tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
ssize_t read_line_nocomments(FILE *file , char *buf , size_t size ) 
{ 
  ssize_t tmp ;

  {
  {
#line 198
  tmp = do_read_line(file, buf, size, (char )'\000', (bool_t *)((void *)0));
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *skip_spaces(char const   *buf ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;

#line 203
    if (*buf) {
      {
#line 203
      tmp = __ctype_b_loc();
      }
#line 203
      if (! ((int const   )*(*tmp + (int )*buf) & 8192)) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 204
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 206
  return ((char *)buf);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *find_space(char const   *buf ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;

#line 211
    if (*buf) {
      {
#line 211
      tmp = __ctype_b_loc();
      }
#line 211
      if ((int const   )*(*tmp + (int )*buf) & 8192) {
#line 211
        goto while_break;
      }
    } else {
#line 211
      goto while_break;
    }
#line 212
    buf ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 214
  return ((char *)buf);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *find_line(char *buf ) 
{ 
  char *tmp ;

  {
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;

#line 219
    if (*buf) {
#line 219
      tmp = buf;
#line 219
      buf ++;
#line 219
      if (! ((int )*tmp != 10)) {
#line 219
        goto while_break;
      }
    } else {
#line 219
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 222
  return (buf);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
char *trim_string(char *buf ) 
{ 
  char *next ;
  char *end ;
  char *tmp ;

  {
  {
#line 229
  buf = skip_spaces((char const   *)buf);
#line 231
  next = buf;
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 232
    tmp = find_space((char const   *)next);
#line 232
    end = tmp;
    }
#line 234
    if ((int )*end == 0) {
#line 235
      goto while_break;
    }
    {
#line 237
    next = skip_spaces((char const   *)end);
    }
#line 238
    if ((int )*next == 0) {
#line 239
      *end = (char )'\000';
#line 240
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 244
  return (buf);
}
}
#line 247 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
int split_string(char *line  , ...) 
{ 
  va_list arg ;
  char **strp ;
  char *str ;
  int n ;
  char **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char **tmp___3 ;

  {
  {
#line 251
  n = 0;
#line 253
  __builtin_va_start(arg, line);
  }
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 256
    tmp___3 = __builtin_va_arg(arg, char **);
#line 256
    tmp = tmp___3;
#line 256
    strp = tmp;
    }
#line 257
    if (! strp) {
#line 258
      goto while_break;
    }
    {
#line 260
    tmp___0 = strlen((char const   *)line);
    }
#line 260
    if (tmp___0 == 0UL) {
#line 261
      *strp = (char *)((void *)0);
#line 262
      goto while_continue;
    }
    {
#line 265
    str = line;
#line 267
    line = find_space((char const   *)line);
    }
#line 268
    if (*line) {
      {
#line 269
      tmp___1 = line;
#line 269
      line ++;
#line 269
      *tmp___1 = (char )'\000';
#line 270
      line = skip_spaces((char const   *)line);
      }
    }
    {
#line 273
    tmp___2 = strlen((char const   *)str);
    }
#line 273
    if (tmp___2 > 0UL) {
#line 274
      *strp = str;
#line 275
      n ++;
    } else {
#line 277
      *strp = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 281
  __builtin_va_end(arg);
  }
#line 283
  return (n);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/common.c"
size_t string_cat(char *buf , size_t bufsize , char const   *piece  , ...) 
{ 
  char *str ;
  ssize_t avail ;
  va_list arg ;
  size_t len ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 292
  __builtin_va_start(arg, piece);
#line 294
  str = buf;
#line 295
  *str = (char )'\000';
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! piece) {
#line 297
      goto while_break;
    }
    {
#line 300
    tmp = strlen((char const   *)str);
#line 300
    avail = (ssize_t )((bufsize - 1UL) - tmp);
    }
#line 301
    if (avail <= 0L) {
#line 302
      goto while_break;
    }
    {
#line 305
    len = strlen(piece);
    }
#line 306
    if (len > (size_t )avail) {
      {
#line 307
      strncat((char */* __restrict  */)str, (char const   */* __restrict  */)piece,
              (size_t )avail);
      }
#line 308
      goto while_break;
    }
    {
#line 311
    strcat((char */* __restrict  */)str, (char const   */* __restrict  */)piece);
#line 313
    tmp___2 = __builtin_va_arg(arg, char *);
#line 313
    tmp___0 = tmp___2;
#line 313
    piece = tmp___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 316
  __builtin_va_end(arg);
#line 318
  tmp___1 = strlen((char const   *)buf);
  }
#line 318
  return (tmp___1);
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.h"
char **get_targets(char const   *filename ) ;
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 184 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static char *is_target(char *tgt , char *buf ) 
{ 
  int a ;
  int b ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 27
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    tmp = tgt;
#line 28
    tgt ++;
#line 28
    a = (int )*tmp;
#line 29
    tmp___0 = buf;
#line 29
    buf ++;
#line 29
    b = (int )*tmp___0;
#line 31
    if (! a) {
#line 31
      goto _L;
    } else
#line 31
    if (! b) {
#line 31
      goto _L;
    } else {
      {
#line 31
      tmp___4 = __ctype_b_loc();
      }
#line 31
      if ((int const   )*(*tmp___4 + b) & 8192) {
        _L: 
#line 32
        if (! a) {
          {
#line 32
          tmp___3 = __ctype_b_loc();
          }
#line 32
          if ((int const   )*(*tmp___3 + b) & 8192) {
#line 32
            tmp___2 = buf;
          } else {
#line 32
            tmp___2 = (char *)((void *)0);
          }
        } else {
#line 32
          tmp___2 = (char *)((void *)0);
        }
#line 32
        return (tmp___2);
      }
    }
#line 34
    if (a != b) {
#line 35
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }

#line 41
  return ((char *)0);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static bool_t read_params(char *buf , config_t *cfg ) 
{ 
  char *host ;
  char *port___0 ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 46
  host = skip_spaces((char const   *)buf);
  }
#line 47
  if (! host) {
    {
#line 48
    tmp = __errno_location();
#line 48
    *tmp = 0;
#line 49
    error("Invalid parameter string");
    }
#line 50
    return ((bool_t )0);
  }
  {
#line 53
  port___0 = strchr((char const   *)host, ':');
  }
#line 54
  if (port___0) {
#line 55
    tmp___0 = port___0;
#line 55
    port___0 ++;
#line 55
    *tmp___0 = (char )'\000';
#line 56
    buf = port___0;
  } else {
#line 58
    port___0 = (char *)((void *)0);
#line 59
    buf = host;
  }
  {
#line 62
  buf = find_space((char const   *)buf);
  }
#line 63
  if (! buf) {
    {
#line 64
    tmp___1 = __errno_location();
#line 64
    *tmp___1 = 0;
#line 65
    error("Invalid parameter string");
    }
#line 66
    return ((bool_t )0);
  }
  {
#line 68
  tmp___2 = buf;
#line 68
  buf ++;
#line 68
  *tmp___2 = (char )'\000';
#line 70
  cfg->host = strdup((char const   *)host);
  }
#line 71
  if (! cfg->host) {
    {
#line 72
    oom_error();
    }
#line 73
    return ((bool_t )0);
  }
#line 76
  if (port___0) {
    {
#line 77
    cfg->port = strdup((char const   *)port___0);
    }
#line 78
    if (! cfg->port) {
      {
#line 79
      oom_error();
      }
#line 80
      return ((bool_t )0);
    }
  }
#line 84
  return ((bool_t )1);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
static bool_t read_opts(FILE *file , char *buf , size_t size , config_t *cfg ) 
{ 
  long pos ;
  size_t cnt ;
  char **p ;
  bool_t blank ;
  ssize_t len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;
  char **tmp___4 ;

  {
  {
#line 90
  cnt = (size_t )0;
#line 93
  pos = ftell(file);
  }
  {
#line 95
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 99
    len = read_line_blank(file, buf, size, & blank);
    }
#line 100
    if (len < 0L) {
#line 101
      goto while_break;
    }
#line 102
    if (blank) {
#line 103
      goto while_break;
    }
#line 104
    if (len > 0L) {
      {
#line 104
      tmp = __ctype_b_loc();
      }
#line 104
      if (! ((int const   )*(*tmp + (int )*(buf + 0)) & 8192)) {
#line 105
        goto while_break;
      }
    }
    {
#line 107
    buf = skip_spaces((char const   *)buf);
#line 108
    tmp___0 = strlen((char const   *)buf);
    }
#line 108
    if (tmp___0 == 0UL) {
#line 109
      goto while_continue;
    }
#line 111
    cnt ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 114
  fseek(file, pos, 0);
#line 116
  tmp___1 = calloc(cnt + 1UL, sizeof(char *));
#line 116
  cfg->opts = (char **)tmp___1;
  }
#line 117
  if (! cfg->opts) {
    {
#line 118
    oom_error();
    }
#line 119
    return ((bool_t )0);
  }
#line 122
  p = cfg->opts;
  {
#line 122
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 122
    if (! (cnt > 0UL)) {
#line 122
      goto while_break___0;
    }
    {
#line 123
    tmp___2 = read_line(file, buf, size);
    }
#line 123
    if (tmp___2 < 0L) {
#line 124
      goto while_break___0;
    }
    {
#line 126
    buf = skip_spaces((char const   *)buf);
#line 127
    tmp___3 = strlen((char const   *)buf);
    }
#line 127
    if (tmp___3 == 0UL) {
#line 128
      goto __Cont;
    }
    {
#line 130
    tmp___4 = p;
#line 130
    p ++;
#line 130
    *tmp___4 = strdup((char const   *)buf);
#line 131
    cnt --;
    }
    __Cont: ;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 134
  return ((bool_t )1);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
bool_t config_read(config_t *cfg , char const   *filename , char const   *target___0 ) 
{ 
  FILE *file ;
  char buf[1024] ;
  char *bufp ;
  ssize_t len ;
  bool_t ok ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  bool_t tmp___1 ;
  bool_t tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 142
  ok = (bool_t )0;
#line 144
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 145
  if (! file) {
    {
#line 146
    error("Can\'t open %s", filename);
    }
#line 147
    return ((bool_t )0);
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: 
    {
#line 151
    len = read_line(file, buf, sizeof(buf));
    }
#line 152
    if (len < 0L) {
      {
#line 153
      tmp = __errno_location();
#line 153
      *tmp = 0;
#line 154
      error("Target %s is not listed in %s", target___0, filename);
      }
#line 155
      goto while_break;
    }
#line 158
    if (len == 0L) {
#line 159
      goto while_continue;
    } else {
      {
#line 158
      tmp___0 = __ctype_b_loc();
      }
#line 158
      if ((int const   )*(*tmp___0 + (int )buf[0]) & 8192) {
#line 159
        goto while_continue;
      }
    }
#line 161
    if (target___0) {
      {
#line 164
      bufp = is_target((char *)target___0, buf);
      }
#line 165
      if (! bufp) {
#line 166
        goto while_continue;
      }
      {
#line 168
      cfg->target = strdup(target___0);
      }
    } else {
      {
#line 173
      bufp = find_space((char const   *)(buf));
#line 174
      cfg->target = strndup((char const   *)(buf), (size_t )(bufp - buf));
      }
    }
    {
#line 177
    tmp___1 = read_params(bufp, cfg);
    }
#line 177
    if (tmp___1) {
      {
#line 177
      tmp___2 = read_opts(file, buf, sizeof(buf), cfg);
      }
#line 177
      if (tmp___2) {
#line 177
        tmp___3 = 1;
      } else {
#line 177
        tmp___3 = 0;
      }
    } else {
#line 177
      tmp___3 = 0;
    }
#line 177
    ok = (bool_t )tmp___3;
#line 178
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 181
  fclose(file);
  }
#line 183
  return (ok);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
config_t *config_alloc(void) 
{ 
  void *tmp ;

  {
  {
#line 188
  tmp = calloc((size_t )1, sizeof(config_t ));
  }
#line 188
  return ((config_t *)tmp);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
void config_free(config_t *cfg ) 
{ 


  {
#line 193
  if (cfg->target) {
    {
#line 194
    free((void *)cfg->target);
    }
  }
#line 196
  if (cfg->host) {
    {
#line 197
    free((void *)cfg->host);
    }
  }
#line 199
  if (cfg->port) {
    {
#line 200
    free((void *)cfg->port);
    }
  }
#line 202
  if (cfg->opts) {
    {
#line 203
    free_vec((void **)cfg->opts, (free_func_t *)((void *)0));
    }
  }
  {
#line 205
  free((void *)cfg);
  }
#line 206
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/config.c"
char **get_targets(char const   *filename ) 
{ 
  FILE *file ;
  char buf[1024] ;
  ssize_t len ;
  size_t cnt ;
  char **targets ;
  char **p ;
  unsigned short const   **tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char **tmp___2 ;
  unsigned short const   **tmp___3 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 216
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 217
  if (! file) {
#line 218
    return ((char **)((void *)0));
  }
#line 220
  cnt = (size_t )0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 221
    len = read_line(file, buf, sizeof(buf));
    }
#line 222
    if (len < 0L) {
#line 223
      goto while_break;
    }
#line 225
    if (len > 0L) {
      {
#line 225
      tmp = __ctype_b_loc();
      }
#line 225
      if (! ((int const   )*(*tmp + (int )buf[0]) & 8192)) {
#line 226
        cnt ++;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: 
  {
#line 229
  rewind(file);
#line 231
  tmp___0 = calloc(cnt + 1UL, sizeof(char *));
#line 231
  targets = (char **)tmp___0;
  }
#line 232
  if (! targets) {
    {
#line 233
    oom_error();
    }
#line 234
    return ((char **)((void *)0));
  }
#line 237
  p = targets;
  {
#line 237
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    len = read_line(file, buf, sizeof(buf));
    }
#line 239
    if (len < 0L) {
#line 240
      goto while_break___0;
    }
#line 242
    if (len > 0L) {
      {
#line 242
      tmp___3 = __ctype_b_loc();
      }
#line 242
      if (! ((int const   )*(*tmp___3 + (int )buf[0]) & 8192)) {
        {
#line 243
        tmp___1 = find_space((char const   *)(buf));
#line 243
        *tmp___1 = (char )'\000';
#line 244
        tmp___2 = p;
#line 244
        p ++;
#line 244
        *tmp___2 = strdup((char const   *)(buf));
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 248
  return (targets);
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.h"
ssize_t write_ni(int fd , void *buf , size_t len ) ;
#line 30
ssize_t read_ni(int fd , void *buf , size_t len ) ;
#line 32
int write_buf(int fd , void *buf , size_t len ) ;
#line 35
int write_uint16(int fd , uint16_t i ) ;
#line 38
int write_uint32(int fd , uint32_t i ) ;
#line 41
int write_uint64(int fd , uint64_t i ) ;
#line 42
int read_uint64(int fd , uint64_t *iptr ) ;
#line 45
uint16v_t *read_uint16v(int fd ) ;
#line 47
int write_str(int fd , char const   *str ) ;
#line 48
char *read_str(int fd ) ;
#line 51
char **read_strv(int fd ) ;
#line 53
int write_mount(int fd , mount_info_t const   *mi ) ;
#line 54
mount_info_t *read_mount(int fd ) ;
#line 57
mount_info_t **read_mountv(int fd ) ;
#line 60
struct winsize *read_winsize(int fd ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 106 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
uint16v_t *uint16v_alloc(uint32_t len ) 
{ 
  char *mem ;
  void *tmp ;
  uint16v_t *ints ;

  {
  {
#line 108
  tmp = malloc(sizeof(uint16v_t ) + (unsigned long )len * sizeof(uint16_t ));
#line 108
  mem = (char *)tmp;
#line 109
  ints = (uint16v_t *)mem;
  }
#line 110
  if (ints) {
#line 111
    ints->len = len;
#line 112
    ints->vec = (uint16_t *)(mem + sizeof(uint16v_t ));
  }
#line 114
  return (ints);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
void uint16v_free(uint16v_t *ints ) 
{ 


  {
  {
#line 119
  free((void *)ints);
  }
#line 120
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
ssize_t read_ni(int fd , void *buf , size_t len ) 
{ 
  ssize_t retval ;
  int *tmp ;

  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    retval = read(fd, buf, len);
    }
#line 128
    if (retval < 0L) {
      {
#line 128
      tmp = __errno_location();
      }
#line 128
      if (! (*tmp == 4)) {
#line 128
        goto while_break;
      }
    } else {
#line 128
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 131
  return (retval);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
ssize_t write_ni(int fd , void *buf , size_t len ) 
{ 
  ssize_t retval ;
  int *tmp ;

  {
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 141
    retval = write(fd, (void const   *)buf, len);
    }
#line 140
    if (retval < 0L) {
      {
#line 140
      tmp = __errno_location();
      }
#line 140
      if (! (*tmp == 4)) {
#line 140
        goto while_break;
      }
    } else {
#line 140
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 143
  return (retval);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16(int fd , uint16_t i ) 
{ 
  uint16_t data ;
  uint16_t tmp ;
  int tmp___0 ;

  {
  {
#line 148
  tmp = htons(i);
#line 148
  data = tmp;
#line 149
  tmp___0 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 149
  return (tmp___0);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint32(int fd , uint32_t i ) 
{ 
  uint32_t data ;
  uint32_t tmp ;
  int tmp___0 ;

  {
  {
#line 154
  tmp = htonl(i);
#line 154
  data = tmp;
#line 155
  tmp___0 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 155
  return (tmp___0);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint64(int fd , uint64_t i ) 
{ 
  uint64_t data ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 160
  tmp = htonl((uint32_t )i);
#line 160
  tmp___0 = htonl((uint32_t )(i >> 32LL));
#line 160
  data = ((uint64_t )tmp << 32LL) | (unsigned long )tmp___0;
#line 161
  tmp___1 = write_buf(fd, (void *)(& data), sizeof(data));
  }
#line 161
  return (tmp___1);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16v(int fd , uint16v_t *ints ) 
{ 
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 166
  tmp = write_uint32(fd, ints->len);
  }
#line 166
  if (tmp < 0) {
#line 167
    return (-1);
  }
#line 169
  if (ints) {
#line 171
    i = 0;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;

#line 171
      if (! ((uint32_t )i < ints->len)) {
#line 171
        goto while_break;
      }
      {
#line 172
      tmp___0 = write_uint16(fd, *(ints->vec + i));
      }
#line 172
      if (tmp___0 < 0) {
#line 173
        return (-1);
      }
#line 171
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 176
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_str(int fd , char const   *str ) 
{ 
  uint32_t len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 189
  if (! str) {
#line 190
    str = "";
  }
  {
#line 192
  tmp = strlen(str);
#line 192
  len = (uint32_t )tmp;
#line 194
  tmp___0 = write_uint32(fd, len);
  }
#line 194
  if (tmp___0 < 0) {
#line 195
    return (-1);
  } else {
    {
#line 194
    tmp___1 = write_buf(fd, (void *)str, (size_t )len);
    }
#line 194
    if (tmp___1 < 0) {
#line 195
      return (-1);
    }
  }
#line 196
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_strv(int fd , char **strv ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char **s ;
  int tmp___1 ;

  {
  {
#line 207
  tmp = calc_vec_len((void **)strv);
#line 207
  tmp___0 = write_uint32(fd, (uint32_t )tmp);
  }
#line 207
  if (tmp___0 < 0) {
#line 208
    return (-1);
  }
#line 210
  if (strv) {
#line 212
    s = strv;
    {
#line 212
    while (1) {
      while_continue: /* CIL Label */ ;

#line 212
      if (! *s) {
#line 212
        goto while_break;
      }
      {
#line 213
      tmp___1 = write_str(fd, (char const   *)*s);
      }
#line 213
      if (tmp___1 < 0) {
#line 214
        return (-1);
      }
#line 212
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 217
  return (0);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_mount(int fd , mount_info_t const   *mi ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 222
  tmp = write_enum(fd, (int )mi->type);
  }
#line 222
  if (tmp < 0) {
#line 225
    return (-1);
  } else {
    {
#line 222
    tmp___0 = write_str(fd, (char const   *)mi->point);
    }
#line 222
    if (tmp___0 < 0) {
#line 225
      return (-1);
    } else {
      {
#line 222
      tmp___1 = write_str(fd, (char const   *)mi->device);
      }
#line 222
      if (tmp___1 < 0) {
#line 225
        return (-1);
      } else {
        {
#line 222
        tmp___2 = write_str(fd, (char const   *)mi->opts);
        }
#line 222
        if (tmp___2 < 0) {
#line 225
          return (-1);
        } else {
          {
#line 222
          tmp___3 = write_uint64(fd, (uint64_t )mi->device_dev);
          }
#line 222
          if (tmp___3) {
#line 225
            return (-1);
          }
        }
      }
    }
  }
#line 226
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_mountv(int fd , mount_info_t **mounts ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  mount_info_t **p ;
  int tmp___1 ;

  {
  {
#line 231
  tmp = calc_vec_len((void **)mounts);
#line 231
  tmp___0 = write_uint32(fd, (uint32_t )tmp);
  }
#line 231
  if (tmp___0 < 0) {
#line 232
    return (-1);
  }
#line 234
  if (mounts) {
#line 236
    p = mounts;
    {
#line 236
    while (1) {
      while_continue: /* CIL Label */ ;

#line 236
      if (! *p) {
#line 236
        goto while_break;
      }
      {
#line 237
      tmp___1 = write_mount(fd, (mount_info_t const   *)*p);
      }
#line 237
      if (tmp___1 < 0) {
#line 238
        return (-1);
      }
#line 236
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: ;
  }
#line 241
  return (0);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_buf(int fd , void *buf , size_t len ) 
{ 
  ssize_t i ;
  ssize_t cnt ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 248
  i = (ssize_t )0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;

#line 248
    if (! ((size_t )i < len)) {
#line 248
      goto while_break;
    }
    {
#line 249
    cnt = write(fd, (void const   *)(buf + i), len - (size_t )i);
    }
#line 250
    if (cnt < 0L) {
      {
#line 251
      tmp = __errno_location();
      }
#line 251
      if (*tmp == 11) {
#line 252
        cnt = (ssize_t )0;
#line 253
        goto __Cont;
      } else {
        {
#line 251
        tmp___0 = __errno_location();
        }
#line 251
        if (*tmp___0 == 4) {
#line 252
          cnt = (ssize_t )0;
#line 253
          goto __Cont;
        }
      }
#line 256
      return (-1);
    }
    __Cont: 
#line 248
    i += cnt;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 260
  return (0);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_buf(int fd , void *buf , size_t len ) 
{ 
  ssize_t i ;
  ssize_t cnt ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 274
  i = (ssize_t )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;

#line 274
    if (! ((size_t )i < len)) {
#line 274
      goto while_break;
    }
    {
#line 275
    cnt = read(fd, buf + i, len - (size_t )i);
    }
#line 276
    if (cnt < 0L) {
      {
#line 277
      tmp = __errno_location();
      }
#line 277
      if (*tmp == 11) {
#line 278
        cnt = (ssize_t )0;
#line 279
        goto __Cont;
      } else {
        {
#line 277
        tmp___0 = __errno_location();
        }
#line 277
        if (*tmp___0 == 4) {
#line 278
          cnt = (ssize_t )0;
#line 279
          goto __Cont;
        }
      }
#line 282
      return (-1);
    }
#line 285
    if (cnt == 0L) {
      {
#line 286
      tmp___1 = __errno_location();
#line 286
      *tmp___1 = 5;
      }
#line 287
      return (-1);
    }
    __Cont: 
#line 274
    i += cnt;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 291
  return (0);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint16(int fd , uint16_t *iptr ) 
{ 
  uint16_t data ;
  int tmp ;

  {
  {
#line 297
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 297
  if (tmp < 0) {
#line 298
    return (-1);
  }
  {
#line 299
  *iptr = ntohs(data);
  }
#line 300
  return (0);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint32(int fd , uint32_t *iptr ) 
{ 
  uint32_t data ;
  int tmp ;

  {
  {
#line 306
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 306
  if (tmp < 0) {
#line 307
    return (-1);
  }
  {
#line 308
  *iptr = ntohl(data);
  }
#line 309
  return (0);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_uint64(int fd , uint64_t *iptr ) 
{ 
  uint64_t data ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  {
#line 315
  tmp = read_buf(fd, (void *)(& data), sizeof(data));
  }
#line 315
  if (tmp < 0) {
#line 316
    return (-1);
  }
  {
#line 317
  tmp___0 = ntohl((uint32_t )data);
#line 317
  tmp___1 = ntohl((uint32_t )(data >> 32LL));
#line 317
  *iptr = ((uint64_t )tmp___0 << 32LL) | (unsigned long )tmp___1;
  }
#line 318
  return (0);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
uint16v_t *read_uint16v(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  uint16v_t *ints ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 326
  tmp = read_uint32(fd, & len);
  }
#line 326
  if (tmp < 0) {
#line 327
    return ((uint16v_t *)((void *)0));
  }
  {
#line 329
  ints = uint16v_alloc(len);
  }
#line 330
  if (! ints) {
#line 331
    return ((uint16v_t *)((void *)0));
  }
#line 333
  i = (uint32_t )0;
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;

#line 333
    if (! (i < len)) {
#line 333
      goto while_break;
    }
    {
#line 334
    tmp___0 = read_uint16(fd, ints->vec + i);
    }
#line 334
    if (tmp___0 < 0) {
      {
#line 335
      uint16v_free(ints);
      }
#line 336
      return ((uint16v_t *)((void *)0));
    }
#line 333
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 339
  return (ints);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
char *read_str(int fd ) 
{ 
  uint32_t len ;
  char *str ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 352
  tmp = read_uint32(fd, & len);
  }
#line 352
  if (tmp < 0) {
#line 353
    return ((char *)((void *)0));
  }
  {
#line 355
  tmp___0 = calloc((size_t )(len + 1U), (size_t )1);
#line 355
  str = (char *)tmp___0;
  }
#line 356
  if (! str) {
#line 357
    return ((char *)((void *)0));
  }
  {
#line 359
  tmp___1 = read_buf(fd, (void *)str, (size_t )len);
  }
#line 359
  if (tmp___1 < 0) {
    {
#line 360
    free((void *)str);
    }
#line 361
    return ((char *)((void *)0));
  }
#line 363
  return (str);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
char **read_strv(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  char **strv ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 377
  tmp = read_uint32(fd, & len);
  }
#line 377
  if (tmp < 0) {
#line 378
    return ((char **)((void *)0));
  }
  {
#line 380
  tmp___0 = calloc((size_t )(len + 1U), sizeof(char *));
#line 380
  strv = (char **)tmp___0;
  }
#line 381
  if (! strv) {
#line 382
    return ((char **)((void *)0));
  }
#line 384
  i = (uint32_t )0;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;

#line 384
    if (! (i < len)) {
#line 384
      goto while_break;
    }
    {
#line 385
    *(strv + i) = read_str(fd);
    }
#line 386
    if (! *(strv + i)) {
      {
#line 387
      free_vec((void **)strv, (free_func_t *)((void *)0));
      }
#line 388
      return ((char **)((void *)0));
    }
#line 384
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 392
  return (strv);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
mount_info_t *read_mount(int fd ) 
{ 
  mount_info_t *mi ;
  mtype_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 399
  mi = mntinfo_alloc();
  }
#line 400
  if (! mi) {
#line 401
    return ((mount_info_t *)((void *)0));
  }
  {
#line 403
  tmp___0 = read_enum(fd);
#line 403
  tmp = (mtype_t )tmp___0;
#line 403
  mi->type = tmp;
  }
#line 403
  if ((unsigned int )tmp >= 0U) {
    {
#line 403
    tmp___1 = read_str(fd);
#line 403
    mi->point = tmp___1;
    }
#line 403
    if (tmp___1) {
      {
#line 403
      tmp___2 = read_str(fd);
#line 403
      mi->device = tmp___2;
      }
#line 403
      if (tmp___2) {
        {
#line 403
        tmp___3 = read_str(fd);
#line 403
        mi->opts = tmp___3;
        }
#line 403
        if (tmp___3) {
          {
#line 403
          tmp___4 = read_uint64(fd, & mi->device_dev);
          }
#line 403
          if (tmp___4 >= 0) {
#line 408
            return (mi);
          }
        }
      }
    }
  }
  {
#line 410
  mntinfo_free(mi);
  }
#line 411
  return ((mount_info_t *)((void *)0));
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
mount_info_t **read_mountv(int fd ) 
{ 
  uint32_t len ;
  uint32_t i ;
  mount_info_t **mounts ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 419
  tmp = read_uint32(fd, & len);
  }
#line 419
  if (tmp < 0) {
#line 420
    return ((mount_info_t **)((void *)0));
  }
  {
#line 422
  tmp___0 = calloc((size_t )(len + 1U), sizeof(mount_info_t *));
#line 422
  mounts = (mount_info_t **)tmp___0;
  }
#line 423
  if (! mounts) {
#line 424
    return ((mount_info_t **)((void *)0));
  }
#line 426
  i = (uint32_t )0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;

#line 426
    if (! (i < len)) {
#line 426
      goto while_break;
    }
    {
#line 427
    *(mounts + i) = read_mount(fd);
    }
#line 428
    if (! *(mounts + i)) {
      {
#line 429
      free_vec((void **)mounts, (free_func_t *)(& mntinfo_free));
      }
#line 430
      return ((mount_info_t **)((void *)0));
    }
#line 426
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 434
  return (mounts);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_winsize(int fd , struct winsize  const  *ws ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 439
  tmp = write_uint16(fd, (uint16_t )ws->ws_row);
  }
#line 439
  if (tmp < 0) {
#line 441
    return (-1);
  } else {
    {
#line 439
    tmp___0 = write_uint16(fd, (uint16_t )ws->ws_col);
    }
#line 439
    if (tmp___0 < 0) {
#line 441
      return (-1);
    } else {
      {
#line 439
      tmp___1 = write_uint16(fd, (uint16_t )ws->ws_xpixel);
      }
#line 439
      if (tmp___1 < 0) {
#line 441
        return (-1);
      } else {
        {
#line 439
        tmp___2 = write_uint16(fd, (uint16_t )ws->ws_ypixel);
        }
#line 439
        if (tmp___2 < 0) {
#line 441
          return (-1);
        }
      }
    }
  }
#line 442
  return (0);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
struct winsize *read_winsize(int fd ) 
{ 
  uint16_t row ;
  uint16_t col ;
  uint16_t xpixel ;
  uint16_t ypixel ;
  struct winsize *ws ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 450
  tmp = read_uint16(fd, & row);
  }
#line 450
  if (tmp < 0) {
#line 452
    return ((struct winsize *)((void *)0));
  } else {
    {
#line 450
    tmp___0 = read_uint16(fd, & col);
    }
#line 450
    if (tmp___0 < 0) {
#line 452
      return ((struct winsize *)((void *)0));
    } else {
      {
#line 450
      tmp___1 = read_uint16(fd, & xpixel);
      }
#line 450
      if (tmp___1 < 0) {
#line 452
        return ((struct winsize *)((void *)0));
      } else {
        {
#line 450
        tmp___2 = read_uint16(fd, & ypixel);
        }
#line 450
        if (tmp___2 < 0) {
#line 452
          return ((struct winsize *)((void *)0));
        }
      }
    }
  }
  {
#line 454
  tmp___3 = malloc(sizeof(struct winsize ));
#line 454
  ws = (struct winsize *)tmp___3;
  }
#line 455
  if (! ws) {
#line 456
    return ((struct winsize *)((void *)0));
  }
#line 458
  ws->ws_row = row;
#line 459
  ws->ws_col = col;
#line 460
  ws->ws_xpixel = xpixel;
#line 461
  ws->ws_ypixel = ypixel;
#line 462
  return (ws);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_enum(int fd , int type ) 
{ 
  int tmp ;

  {
  {
#line 467
  tmp = write_uint16(fd, (uint16_t )type);
  }
#line 467
  return (tmp);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int read_enum(int fd ) 
{ 
  uint16_t type ;
  int tmp ;

  {
  {
#line 473
  tmp = read_uint16(fd, & type);
  }
#line 473
  if (tmp < 0) {
#line 474
    return (-1);
  }
#line 475
  return ((int )type);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_buf_packet(int fd , ptype_t type , size_t size , void *buf ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 480
  tmp = write_enum(fd, (int )type);
  }
#line 480
  if (tmp < 0) {
#line 481
    return (-1);
  } else {
    {
#line 480
    tmp___0 = write_uint32(fd, (uint32_t )size);
    }
#line 480
    if (tmp___0 < 0) {
#line 481
      return (-1);
    } else {
      {
#line 480
      tmp___1 = write_buf(fd, buf, size);
      }
#line 480
      if (tmp___1 < 0) {
#line 481
        return (-1);
      }
    }
  }
#line 482
  return (0);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_str_packet(int fd , ptype_t type , char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 487
  tmp = write_enum(fd, (int )type);
  }
#line 487
  if (tmp < 0) {
#line 488
    return (-1);
  } else {
    {
#line 487
    tmp___0 = write_str(fd, (char const   *)((char *)str));
    }
#line 487
    if (tmp___0 < 0) {
#line 488
      return (-1);
    }
  }
#line 489
  return (0);
}
}
#line 492 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int write_uint16_packet(int fd , ptype_t type , uint16_t val ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 494
  tmp = write_enum(fd, (int )type);
  }
#line 494
  if (tmp < 0) {
#line 495
    return (-1);
  } else {
    {
#line 494
    tmp___0 = write_uint16(fd, val);
    }
#line 494
    if (tmp___0 < 0) {
#line 495
      return (-1);
    }
  }
#line 496
  return (0);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int send_version(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 506
  tmp = write_enum(fd, 11);
  }
#line 506
  if (tmp < 0) {
#line 507
    return (-1);
  } else {
    {
#line 506
    tmp___0 = write_uint16(fd, (uint16_t )7);
    }
#line 506
    if (tmp___0 < 0) {
#line 507
      return (-1);
    }
  }
#line 508
  return (0);
}
}
#line 516 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/protocol.c"
int get_version(int fd ) 
{ 
  uint16_t ver ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 519
  tmp___0 = read_enum(fd);
  }
#line 519
  if (tmp___0 != 11) {
    {
#line 520
    tmp = __errno_location();
#line 520
    *tmp = 0;
    }
#line 521
    return (-1);
  }
  {
#line 523
  tmp___1 = read_uint16(fd, & ver);
  }
#line 523
  if (tmp___1 < 0) {
#line 524
    return (-1);
  }
#line 525
  return ((int )ver);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.h"
void buf_free(buffer_t *buf ) ;
#line 27
void buf_set_eof(buffer_t *buf ) ;
#line 28
size_t buf_size(buffer_t *buf ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
buffer_t *buf_alloc(void) 
{ 
  buffer_t *buf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 25
  tmp = calloc((size_t )1, sizeof(buffer_t ));
#line 25
  buf = (buffer_t *)tmp;
  }
#line 26
  if (buf) {
    {
#line 27
    buf->mem_size = (size_t )4096;
#line 28
    tmp___0 = malloc((size_t )4096);
#line 28
    buf->mem = (uint8_t *)tmp___0;
    }
#line 29
    if (! buf->mem) {
      {
#line 30
      free((void *)buf);
#line 31
      buf = (buffer_t *)0;
      }
    }
  }
#line 34
  return (buf);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
void buf_free(buffer_t *buf ) 
{ 


  {
#line 43
  if (buf->mem) {
    {
#line 44
    free((void *)buf->mem);
    }
  }
  {
#line 46
  free((void *)buf);
  }
#line 47
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
void buf_set_eof(buffer_t *buf ) 
{ 


  {
#line 56
  buf->eof = (bool_t )1;
#line 57
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
size_t buf_size(buffer_t *buf ) 
{ 


  {
#line 66
  return (buf->end - buf->start);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
bool_t buf_is_empty(buffer_t *buf ) 
{ 
  int tmp ;

  {
#line 76
  if (buf->end == 0UL) {
#line 76
    if (buf->eof == 0U) {
#line 76
      tmp = 1;
    } else {
#line 76
      tmp = 0;
    }
  } else {
#line 76
    tmp = 0;
  }
#line 76
  return ((bool_t )tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
ssize_t buf_read_in(buffer_t *buf , int fd , size_t len ) 
{ 
  size_t size ;
  uint8_t *mem ;
  void *tmp ;
  int tmp___0 ;

  {
#line 95
  size = buf->end + len;
#line 96
  if (size > buf->mem_size) {
    {
#line 101
    tmp = malloc(size);
#line 101
    mem = (uint8_t *)tmp;
    }
#line 102
    if (! mem) {
#line 103
      return ((ssize_t )-1);
    }
    {
#line 106
    memcpy((void */* __restrict  */)((void *)mem), (void const   */* __restrict  */)((void const   *)buf->mem),
           buf->mem_size);
#line 107
    free((void *)buf->mem);
#line 109
    buf->mem_size = size;
#line 110
    buf->mem = mem;
    }
  }
  {
#line 113
  tmp___0 = read_buf(fd, (void *)(buf->mem + buf->end), len);
  }
#line 113
  if (tmp___0 < 0) {
#line 114
    return ((ssize_t )-1);
  }
#line 117
  buf->end += len;
#line 119
  return ((ssize_t )len);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/buffer.c"
ssize_t buf_write_out(buffer_t *buf , int *fd ) 
{ 
  size_t size ;
  ssize_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 132
  len = (ssize_t )0;
#line 134
  size = buf_size(buf);
  }
#line 135
  if (size) {
    {
#line 138
    len = write_ni(*fd, (void *)(buf->mem + buf->start), size);
    }
#line 139
    if (len < 0L) {
      {
#line 140
      tmp = __errno_location();
      }
#line 140
      if (*tmp == 11) {
#line 141
        len = (ssize_t )0;
      } else {
        {
#line 143
        close(*fd);
#line 144
        *fd = -1;
        }
#line 146
        return ((ssize_t )-1);
      }
    }
    {
#line 150
    buf->start += (size_t )len;
#line 152
    size = buf_size(buf);
    }
#line 153
    if (size == 0UL) {
#line 154
      buf->start = (size_t )0;
#line 155
      buf->end = (size_t )0;
    }
  }
#line 159
  if (size == 0UL) {
#line 159
    if (buf->eof) {
      {
#line 160
      close(*fd);
#line 161
      *fd = -1;
#line 162
      tmp___0 = __errno_location();
#line 162
      *tmp___0 = 0;
#line 165
      buf->eof = (bool_t )0;
      }
    }
  }
#line 168
  return (len);
}
}
#line 233 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 157 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.h"
FILE *debug_file ;
#line 159
void set_debug_name(char const   *name ) ;
#line 160
void print_debug(char const   *msg  , ...) ;
#line 161
void send_error(handler_t *data , char const   *msg  , ...) ;
#line 163
int daemonize(int listenfd ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.h"
int fakeroot_relay(handler_t *data ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 983
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getdtablesize)(void) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void syslog(int __pri , char const   *__fmt  , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 239 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
FILE *debug_file  =    (FILE *)((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static struct __anonstruct_debug_info_88 debug_info  =    {-1, (char const   *)((void *)0)};
#line 94 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void set_debug_name(char const   *name ) 
{ 


  {
  {
#line 96
  debug_info.pid = getpid();
#line 97
  debug_info.name = name;
  }
#line 98
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_debug_prefix(void) 
{ 
  struct timeval tv ;
  struct tm *t ;
  char const   *domain ;
  __pid_t tmp ;
  __pid_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 107
  domain = "";
#line 109
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 110
  t = gmtime((time_t const   *)(& tv.tv_sec));
#line 112
  tmp = getpid();
  }
#line 112
  if (debug_info.pid == tmp) {
#line 113
    domain = debug_info.name;
  }
  {
#line 115
  tmp___0 = getpid();
#line 115
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"%02d-%02d-%04d %02d:%02d:%02d.%03ld %5d %7s ",
          t->tm_mday, t->tm_mon + 1, 1900 + t->tm_year, t->tm_hour, t->tm_min, t->tm_sec,
          tv.tv_usec / 1000L, tmp___0, domain);
  }
#line 118
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void print_debug(char const   *msg  , ...) 
{ 
  va_list arg ;
  char *__cil_tmp3 ;

  {
  {
#line 176
  print_debug_prefix();
#line 178
  __builtin_va_start(arg, msg);
#line 179
  vfprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)msg,
           arg);
#line 180
  __builtin_va_end(arg);
#line 182
  fprintf((FILE */* __restrict  */)debug_file, (char const   */* __restrict  */)"\n");
#line 183
  fflush(debug_file);
  }
#line 184
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
static void print_error(handler_t *data , char const   *progname___0 , char const   *msg ,
                        va_list arg , int priority ) 
{ 
  char str[1024] ;
  unsigned int tmp ;
  char *err ;
  size_t len ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 208
  str[0] = (char )'\000';
#line 208
  tmp = 1U;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;

#line 208
    if (tmp >= 1024U) {
#line 208
      goto while_break;
    }
#line 208
    str[tmp] = (char)0;
#line 208
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 211
  vsnprintf((char */* __restrict  */)(str), sizeof(str) - 1UL, (char const   */* __restrict  */)msg,
            arg);
#line 212
  len = strlen((char const   *)(str));
#line 214
  tmp___0 = __errno_location();
#line 214
  err = strerror(*tmp___0);
#line 215
  tmp___1 = __errno_location();
  }
#line 215
  if (*tmp___1) {
#line 215
    if (err) {
      {
#line 215
      tmp___2 = strlen((char const   *)err);
      }
#line 215
      if ((len + tmp___2) + 3UL < sizeof(str)) {
        {
#line 216
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)" (");
#line 217
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)((char const   *)err));
#line 218
        strcat((char */* __restrict  */)(str), (char const   */* __restrict  */)")");
#line 220
        len = strlen((char const   *)(str));
        }
      }
    }
  }
#line 223
  if (progname___0) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s\n",
            progname___0, str);
    }
  } else {
    {
#line 226
    syslog(priority, "%s", str);
    }
#line 227
    if (debug_file) {
#line 227
      if (priority == 4) {
#line 227
        tmp___3 = "Warning: %s";
      } else {
#line 227
        tmp___3 = "Error: %s";
      }
      {
#line 227
      print_debug(tmp___3, str);
      }
    }
  }
#line 230
  if (data) {
    {
#line 231
    write_str_packet(data->sd, (ptype_t )17, (char const   *)(str));
    }
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
void send_error(handler_t *data , char const   *msg  , ...) 
{ 
  va_list arg ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 238
  if (! msg) {
    {
#line 239
    tmp = __errno_location();
#line 239
    tmp___0 = strerror(*tmp);
#line 239
    msg = (char const   *)tmp___0;
#line 240
    tmp___1 = __errno_location();
#line 240
    *tmp___1 = 0;
    }
  }
  {
#line 243
  __builtin_va_start(arg, msg);
#line 244
  print_error(data, (char const   *)((void *)0), msg, arg, 3);
#line 245
  __builtin_va_end(arg);
  }
#line 246
  return;
}
}
#line 2818 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/daemon.c"
int daemonize(int listenfd ) 
{ 
  int debugfd ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 2822
  chdir("/");
#line 2823
  umask((__mode_t )0);
  }
#line 2826
  if (debug_file) {
    {
#line 2826
    tmp = fileno(debug_file);
#line 2826
    debugfd = tmp;
    }
  } else {
#line 2826
    debugfd = -1;
  }
  {
#line 2828
  fd = getdtablesize();
  }
  {
#line 2828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2828
    tmp___0 = fd;
#line 2828
    fd --;
#line 2828
    if (! (tmp___0 > 0)) {
#line 2828
      goto while_break;
    }
#line 2829
    if (fd != listenfd) {
#line 2829
      if (fd != debugfd) {
        {
#line 2830
        close(fd);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: 
  {
#line 2832
  fd = open("/dev/null", 2);
  }
#line 2833
  if (fd < 0) {
    {
#line 2834
    error("Can\'t open /dev/null");
    }
#line 2835
    return (-1);
  }
#line 2840
  if (debugfd >= 0) {
#line 2841
    fd = debugfd;
  }
  {
#line 2843
  tmp___1 = dup2(fd, 1);
  }
#line 2843
  if (tmp___1 != 1) {
    {
#line 2844
    error("Can\'t duplicate descriptor %d as stdout", fd);
    }
#line 2845
    return (-1);
  }
  {
#line 2848
  tmp___2 = dup2(fd, 2);
  }
#line 2848
  if (tmp___2 != 2) {
    {
#line 2849
    error("Can\'t duplicate descriptor %d as stderr", fd);
    }
#line 2850
    return (-1);
  }
#line 2853
  return (0);
}
}
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static unsigned int volatile   parent_alive  =    (bool_t volatile   )((bool_t )1);
#line 42 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int volatile   listen_sd  =    (int volatile   )-1;
#line 43 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static uint32_t relay_id  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void append_node(handler_t *data , node_t **head , int client_sd , int daemon_sd ) 
{ 
  node_t *node ;
  node_t *n ;
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 49
  tmp = calloc((size_t )1, sizeof(node_t ));
#line 49
  node = (node_t *)tmp;
  }
#line 50
  if (! node) {
    {
#line 51
    tmp___0 = __errno_location();
#line 51
    *tmp___0 = 0;
#line 52
    send_error(data, oom);
#line 53
    exit(1);
    }
  }
#line 56
  node->client = client_sd;
#line 57
  node->daemon = daemon_sd;
#line 59
  if (*head) {
#line 60
    n = *head;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;

#line 60
      if (! n->next) {
#line 60
        goto while_break;
      }
#line 60
      n = n->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 61
    n->next = node;
  } else {
#line 63
    *head = node;
  }
#line 65
  return;
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void remove_node(node_t **head , node_t *node ) 
{ 
  node_t *n ;
  char *__cil_tmp4 ;

  {
#line 71
  if ((unsigned long )*head == (unsigned long )node) {
#line 72
    *head = node->next;
  } else {
#line 74
    n = *head;
    {
#line 74
    while (1) {
      while_continue: /* CIL Label */ ;

#line 74
      if (! ((unsigned long )n->next != (unsigned long )node)) {
#line 74
        goto while_break;
      }
#line 74
      n = n->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: 
#line 75
    n->next = node->next;
  }
#line 78
  if (debug_file) {
    {
#line 78
    print_debug("Removing node: client=%d, daemon=%d", node->client, node->daemon);
    }
  }
  {
#line 80
  close(node->client);
#line 81
  close(node->daemon);
#line 83
  free((void *)node);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void get_device_numbers(handler_t *data ) 
{ 
  mount_t **ptr ;
  mount_t *m ;
  struct stat buf ;
  int tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 90
  if (! data->mounts) {
#line 91
    if (debug_file) {
      {
#line 91
      print_debug("No mounts");
      }
    }
#line 92
    return;
  }
#line 95
  ptr = data->mounts;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;

#line 95
    if (! *ptr) {
#line 95
      goto while_break;
    }
#line 96
    m = *ptr;
#line 98
    if ((unsigned int )m->info.type != 2U) {
#line 98
      if ((long long )m->point_dev == 0LL) {
        {
#line 101
        tmp = stat((char const   */* __restrict  */)((char const   *)m->info.point),
                   (struct stat */* __restrict  */)(& buf));
        }
#line 101
        if (tmp < 0) {
          {
#line 102
          send_error(data, "Can\'t stat %s", m->info.point);
#line 103
          exit(1);
          }
        }
#line 106
        m->point_dev = buf.st_dev;
#line 108
        if (debug_file) {
          {
#line 108
          print_debug("Device number of %s is %lld", m->info.device, m->info.device_dev);
          }
        }
#line 109
        if (debug_file) {
          {
#line 109
          print_debug("Device number of %s is %lld", m->info.point, m->point_dev);
          }
        }
      }
    }
#line 95
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 112
  return;
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static bool_t translate_dev(handler_t *data , node_t *node , struct fakestat *st ) 
{ 
  mount_t **ptr ;
  fake_dev_t old ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  mount_t const   *m ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 117
  tmp = ntohl((uint32_t )st->dev);
#line 117
  tmp___0 = ntohl((uint32_t )(st->dev >> 32LL));
#line 117
  old = ((uint64_t )tmp << 32LL) | (unsigned long )tmp___0;
#line 119
  node->stored_dev = st->dev;
  }
#line 121
  if (! data->mounts) {
#line 122
    if (debug_file) {
      {
#line 122
      print_debug("No mounts");
      }
    }
#line 123
    return ((bool_t )0);
  }
#line 126
  ptr = data->mounts;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;

#line 126
    if (! *ptr) {
#line 126
      goto while_break;
    }
#line 127
    m = (mount_t const   *)*ptr;
#line 129
    if (old == (fake_dev_t )m->point_dev) {
#line 130
      if (debug_file) {
        {
#line 130
        print_debug("Translating device number: %lld -> %lld", old, m->info.device_dev);
        }
      }
      {
#line 132
      tmp___1 = htonl((uint32_t )m->info.device_dev);
#line 132
      tmp___2 = htonl((uint32_t )(m->info.device_dev >> 32LL));
#line 132
      st->dev = ((uint64_t )tmp___1 << 32LL) | (unsigned long )tmp___2;
      }
#line 133
      return ((bool_t )1);
    }
#line 126
    ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: ;
#line 137
  if (debug_file) {
    {
#line 137
    print_debug("No match for device number %lld", old);
    }
  }
#line 138
  return ((bool_t )0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void restore_dev(node_t *node , struct fakestat *st ) 
{ 
  char *__cil_tmp3 ;

  {
#line 143
  if (debug_file) {
    {
#line 143
    print_debug("Restoring device number");
    }
  }
#line 145
  st->dev = node->stored_dev;
#line 146
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int copy_msg(handler_t *data , node_t *node , direction_t direction ) 
{ 
  int source ;
  int destination ;
  struct fake_msg buf ;
  ssize_t len ;
  int *tmp ;
  uint32_t tmp___0 ;
  bool_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 154
  if ((unsigned int )direction == 1U) {
#line 155
    source = node->client;
#line 156
    destination = node->daemon;
#line 158
    if (debug_file) {
      {
#line 158
      print_debug("Processing message from client=%d", source);
      }
    }
  } else {
#line 160
    source = node->daemon;
#line 161
    destination = node->client;
#line 163
    if (debug_file) {
      {
#line 163
      print_debug("Processing message from daemon=%d", source);
      }
    }
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 167
    len = read(source, (void *)(& buf), sizeof(buf));
    }
#line 168
    if (len >= 0L) {
#line 169
      goto while_break;
    }
    {
#line 171
    tmp = __errno_location();
    }
#line 171
    if (*tmp != 4) {
      {
#line 172
      send_error(data, "Can\'t read from socket");
#line 173
      exit(1);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: ;
#line 177
  if (len == 0L) {
#line 178
    if (debug_file) {
      {
#line 178
      print_debug("No message");
      }
    }
#line 179
    return (-1);
  }
#line 182
  if ((unsigned int )direction == 1U) {
    {
#line 183
    tmp___1 = translate_dev(data, node, & buf.st);
    }
#line 183
    if (tmp___1) {
      {
#line 184
      buf.remote = htonl((uint32_t )0);
      }
    } else {
      {
#line 185
      tmp___0 = ntohl(buf.remote);
      }
#line 185
      if (tmp___0 == 0U) {
#line 186
        if (debug_file) {
          {
#line 186
          print_debug("Setting remote ID");
          }
        }
        {
#line 187
        buf.remote = htonl(relay_id);
        }
      }
    }
  } else {
    {
#line 190
    restore_dev(node, & buf.st);
    }
  }
#line 193
  if ((unsigned int )direction == 1U) {
#line 194
    if (debug_file) {
      {
#line 194
      print_debug("Forwarding message to daemon=%d", destination);
      }
    }
  } else
#line 196
  if (debug_file) {
    {
#line 196
    print_debug("Forwarding message to client=%d", destination);
    }
  }
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 200
    tmp___2 = write(destination, (void const   *)(& buf), sizeof(buf));
    }
#line 200
    if (tmp___2 >= 0L) {
#line 201
      goto while_break___0;
    }
    {
#line 203
    tmp___3 = __errno_location();
    }
#line 203
    if (*tmp___3 != 4) {
      {
#line 204
      send_error(data, "Can\'t write to socket");
#line 205
      exit(1);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: ;
#line 209
  return (0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int get_daemon(handler_t *data , struct sockaddr_in *addr ) 
{ 
  int sd___0 ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 216
  sd___0 = socket(2, 1, 0);
  }
#line 217
  if (sd___0 < 0) {
    {
#line 218
    send_error(data, "Can\'t create socket");
#line 219
    exit(1);
    }
  }
  {
#line 222
  tmp___0 = connect(sd___0, (struct sockaddr  const  *)((struct sockaddr *)addr),
                    (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 222
  if (tmp___0 < 0) {
    {
#line 223
    tmp = __errno_location();
    }
#line 223
    if (*tmp == 4) {
#line 224
      if (debug_file) {
        {
#line 224
        print_debug("Connect interrupted");
        }
      }
      {
#line 225
      exit(0);
      }
    }
    {
#line 228
    send_error(data, "Connect failed");
#line 229
    exit(1);
    }
  }
#line 232
  if (debug_file) {
    {
#line 232
    print_debug("Connected to daemon=%d", sd___0);
    }
  }
#line 234
  return (sd___0);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static int get_client(handler_t *data ) 
{ 
  struct sockaddr_in addr ;
  socklen_t len ;
  int sd___0 ;
  int *tmp ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 240
  len = (socklen_t )sizeof(addr);
#line 243
  sd___0 = accept((int )listen_sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                  (socklen_t */* __restrict  */)(& len));
  }
#line 244
  if (sd___0 < 0) {
    {
#line 245
    tmp = __errno_location();
    }
#line 245
    if (*tmp == 4) {
#line 246
      if (debug_file) {
        {
#line 246
        print_debug("Accept interrupted");
        }
      }
      {
#line 247
      exit(0);
      }
    }
    {
#line 250
    send_error(data, "Accept failed");
#line 251
    exit(1);
    }
  }
#line 254
  if (debug_file) {
    {
#line 254
    print_debug("Connection from client=%d", sd___0);
    }
  }
#line 256
  return (sd___0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void do_relay(handler_t *data , int port___0 ) 
{ 
  struct hostent *host ;
  struct sockaddr_in addr ;
  node_t *sd_head ;
  fd_set fds ;
  int maxfd ;
  int count ;
  node_t *n ;
  node_t *next ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int cli ;
  int dae ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 262
  addr.sin_family = (sa_family_t )0;
#line 262
  addr.sin_port = (unsigned short)0;
#line 262
  addr.sin_addr.s_addr = 0U;
#line 262
  addr.sin_zero[0] = (unsigned char)0;
#line 262
  addr.sin_zero[1] = (unsigned char)0;
#line 262
  addr.sin_zero[2] = (unsigned char)0;
#line 262
  addr.sin_zero[3] = (unsigned char)0;
#line 262
  addr.sin_zero[4] = (unsigned char)0;
#line 262
  addr.sin_zero[5] = (unsigned char)0;
#line 262
  addr.sin_zero[6] = (unsigned char)0;
#line 262
  addr.sin_zero[7] = (unsigned char)0;
#line 263
  sd_head = (node_t *)((void *)0);
#line 266
  host = gethostbyname((char const   *)(data->host));
  }
#line 267
  if (! host) {
    {
#line 268
    send_error(data, "Can\'t resolve host: %s", data->host);
#line 269
    exit(1);
    }
  }
  {
#line 272
  addr.sin_family = (sa_family_t )2;
#line 273
  addr.sin_addr.s_addr = *((unsigned int *)*(host->h_addr_list + 0));
#line 274
  addr.sin_port = htons((uint16_t )port___0);
  }
#line 276
  if (debug_file) {
    {
#line 276
    print_debug("Fakeroot daemon assumed to be at %s:%d", data->host, port___0);
    }
  }
  {
#line 278
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: ;
#line 278
    if (! parent_alive) {
#line 278
      goto while_break;
    }
    {
#line 282
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 282
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 282
      goto while_break___0;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: 
#line 284
    fds.__fds_bits[listen_sd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] |= 1L << listen_sd % (int volatile   )(8 * (int )sizeof(__fd_mask ));
#line 285
    maxfd = (int )listen_sd;
#line 287
    n = sd_head;
#line 287
    count = 0;
    {
#line 287
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 287
      if (! n) {
#line 287
        goto while_break___1;
      }
#line 288
      fds.__fds_bits[n->daemon / (8 * (int )sizeof(__fd_mask ))] |= 1L << n->daemon % (8 * (int )sizeof(__fd_mask ));
#line 289
      fds.__fds_bits[n->client / (8 * (int )sizeof(__fd_mask ))] |= 1L << n->client % (8 * (int )sizeof(__fd_mask ));
#line 290
      if (maxfd > n->daemon) {
#line 290
        maxfd = maxfd;
      } else {
#line 290
        maxfd = n->daemon;
      }
#line 291
      if (maxfd > n->client) {
#line 291
        maxfd = maxfd;
      } else {
#line 291
        maxfd = n->client;
      }
#line 287
      n = n->next;
#line 287
      count ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: ;
#line 294
    if (debug_file) {
      {
#line 294
      print_debug("Selecting (%d nodes)", count);
      }
    }
    {
#line 296
    tmp___0 = select(maxfd + 1, (fd_set */* __restrict  */)(& fds), (fd_set */* __restrict  */)((fd_set *)((void *)0)),
                     (fd_set */* __restrict  */)((fd_set *)((void *)0)), (struct timeval */* __restrict  */)((struct timeval *)((void *)0)));
    }
#line 296
    if (tmp___0 < 0) {
#line 297
      if (! parent_alive) {
#line 298
        if (debug_file) {
          {
#line 298
          print_debug("SIGEXIT caught during select call");
          }
        }
#line 299
        goto while_break;
      }
      {
#line 302
      tmp = __errno_location();
      }
#line 302
      if (*tmp == 4) {
#line 303
        if (debug_file) {
          {
#line 303
          print_debug("Select interrupted");
          }
        }
#line 304
        goto while_continue;
      }
      {
#line 307
      send_error(data, "Select failed");
#line 308
      exit(1);
      }
    }
#line 311
    n = sd_head;
    {
#line 311
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 311
      if (! n) {
#line 311
        goto while_break___2;
      }
#line 312
      next = n->next;
#line 314
      if ((fds.__fds_bits[n->daemon / (8 * (int )sizeof(__fd_mask ))] & (1L << n->daemon % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 314
        tmp___1 = copy_msg(data, n, (direction_t )0);
        }
#line 314
        if (tmp___1 < 0) {
          {
#line 315
          remove_node(& sd_head, n);
          }
#line 316
          goto __Cont;
        }
      }
#line 319
      if ((fds.__fds_bits[n->client / (8 * (int )sizeof(__fd_mask ))] & (1L << n->client % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 319
        tmp___2 = copy_msg(data, n, (direction_t )1);
        }
#line 319
        if (tmp___2 < 0) {
          {
#line 320
          remove_node(& sd_head, n);
          }
        }
      }
      __Cont: 
#line 311
      n = next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: ;
#line 324
    if ((fds.__fds_bits[listen_sd / (int volatile   )(8 * (int )sizeof(__fd_mask ))] & (1L << listen_sd % (int volatile   )(8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 327
      cli = get_client(data);
#line 328
      dae = get_daemon(data, & addr);
#line 330
      append_node(data, & sd_head, cli, dae);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: ;
#line 334
  if (debug_file) {
    {
#line 334
    print_debug("Exiting");
    }
  }
#line 335
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static void sig_exit___0(int sig ) 
{ 
  int stored_errno ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 339
  tmp = __errno_location();
#line 339
  stored_errno = *tmp;
#line 341
  parent_alive = (unsigned int volatile   )((bool_t )0);
  }
#line 343
  if (listen_sd >= (int volatile   )0) {
    {
#line 344
    close((int )listen_sd);
    }
  }
  {
#line 346
  tmp___0 = __errno_location();
#line 346
  *tmp___0 = stored_errno;
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
static pid_t fork_relay(handler_t *data , uint16_t *portp ) 
{ 
  int faked_port ;
  int sd___0 ;
  struct sockaddr_in addr ;
  socklen_t len ;
  uint32_t id ;
  pid_t pid ;
  struct sigaction act_exit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 358
  faked_port = (int )*portp;
#line 360
  sd___0 = socket(2, 1, 0);
  }
#line 361
  if (sd___0 < 0) {
    {
#line 362
    send_error(data, "Can\'t create socket");
    }
#line 363
    return (-1);
  }
  {
#line 366
  tmp = setsockopt_bool(sd___0, 1, 2, (bool_t )1);
  }
#line 366
  if (tmp) {
    {
#line 367
    send_error(data, "Can\'t set socket option: SO_REUSEADDR");
    }
#line 368
    goto _error;
  }
  {
#line 371
  tmp___0 = listen(sd___0, 128);
  }
#line 371
  if (tmp___0 < 0) {
    {
#line 372
    send_error(data, "Can\'t listen to socket");
    }
#line 373
    goto _error;
  }
  {
#line 376
  len = (socklen_t )sizeof(addr);
#line 377
  tmp___1 = getsockname(sd___0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 377
  if (tmp___1 < 0) {
    {
#line 378
    send_error(data, "Can\'t get name of relay listening socket");
    }
#line 379
    goto _error;
  }
  {
#line 382
  *portp = ntohs(addr.sin_port);
#line 384
  len = (socklen_t )sizeof(addr);
#line 385
  tmp___2 = getsockname(data->sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 385
  if (tmp___2 < 0) {
    {
#line 386
    send_error(data, "Can\'t get name of client connection socket");
    }
#line 387
    goto _error;
  }
  {
#line 390
  id = ntohl(addr.sin_addr.s_addr);
#line 392
  pid = fork();
  }
#line 393
  if (pid < 0) {
    {
#line 394
    send_error(data, "Can\'t fork");
    }
#line 395
    goto _error;
  }
#line 398
  if (pid > 0) {
    {
#line 400
    close(sd___0);
    }
#line 401
    return (pid);
  }
  {
#line 406
  set_debug_name("RELAY");
  }
#line 407
  if (debug_file) {
    {
#line 407
    print_debug("Relaying fakeroot messages at port %d", (int )*portp);
    }
  }
#line 408
  if (debug_file) {
    {
#line 408
    print_debug("Remote ID of this relay is 0x%lx", id);
    }
  }
  {
#line 410
  daemonize(sd___0);
#line 412
  act_exit.__sigaction_handler.sa_handler = & sig_exit___0;
#line 413
  sigemptyset(& act_exit.sa_mask);
#line 414
  act_exit.sa_flags = 0;
#line 416
  sigaction(1, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& act_exit)),
            (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
#line 417
  sigaction(15, (struct sigaction  const  */* __restrict  */)((struct sigaction  const  *)(& act_exit)),
            (struct sigaction */* __restrict  */)((struct sigaction *)((void *)0)));
#line 419
  get_device_numbers(data);
#line 421
  listen_sd = (int volatile   )sd___0;
#line 422
  relay_id = id;
#line 424
  do_relay(data, faked_port);
#line 425
  exit(0);
  }
  _error: 
  {
#line 428
  close(sd___0);
  }
#line 429
  return (-1);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/sbrsh-7.6.1/fakeroot.c"
int fakeroot_relay(handler_t *data ) 
{ 
  char **old_environ ;
  char *str ;
  uint16_t port___0 ;
  pid_t pid ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 439
  old_environ = environ;
#line 440
  environ = data->param.environ;
#line 441
  str = getenv("FAKEROOTKEY");
#line 442
  environ = old_environ;
  }
#line 444
  if (! str) {
#line 445
    return (0);
  } else
#line 444
  if (! *str) {
#line 445
    return (0);
  }
#line 447
  if (debug_file) {
    {
#line 447
    print_debug("Creating relay process");
    }
  }
  {
#line 449
  tmp = atoi((char const   *)str);
#line 449
  port___0 = (uint16_t )tmp;
  }
#line 450
  if ((int )port___0 == 0) {
    {
#line 451
    send_error(data, "Invalid FAKEROOTKEY: %s", str);
    }
#line 452
    return (-1);
  }
  {
#line 455
  pid = fork_relay(data, & port___0);
  }
#line 456
  if (pid < 0) {
#line 457
    return (-1);
  }
  {
#line 459
  tmp___0 = strlen("FAKEROOTKEY");
#line 459
  tmp___1 = malloc(((tmp___0 + 1UL) + 5UL) + 1UL);
#line 459
  data->fakerootkey = (char *)tmp___1;
  }
#line 460
  if (! data->fakerootkey) {
    {
#line 461
    tmp___2 = __errno_location();
#line 461
    *tmp___2 = 0;
#line 462
    send_error(data, oom);
    }
#line 463
    goto _kill;
  }
  {
#line 466
  sprintf((char */* __restrict  */)data->fakerootkey, (char const   */* __restrict  */)"FAKEROOTKEY=%d",
          (int )port___0);
  }
#line 468
  return (pid);
  _kill: 
  {
#line 471
  kill(pid, 15);
  }
#line 472
  return (-1);
}
}
